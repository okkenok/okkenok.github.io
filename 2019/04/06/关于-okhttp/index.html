<!DOCTYPE html>
<html lang=en>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="简单使用Http Get12345678910111213141516171819OkhttpClient mOkHttpClient = new OkHttpClient();final Request request = new Request.Builder()    .url(&quot;https://www.baidu.com&quot;)    .build(); //可设置更多的参数：header、m">
<meta name="keywords" content="Android 面试">
<meta property="og:type" content="article">
<meta property="og:title" content="关于 okhttp">
<meta property="og:url" content="http://yoursite.com/2019/04/06/关于-okhttp/index.html">
<meta property="og:site_name" content="Okkenok">
<meta property="og:description" content="简单使用Http Get12345678910111213141516171819OkhttpClient mOkHttpClient = new OkHttpClient();final Request request = new Request.Builder()    .url(&quot;https://www.baidu.com&quot;)    .build(); //可设置更多的参数：header、m">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7866586-db6c625e9fa03ae0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">
<meta property="og:updated_time" content="2019-04-06T14:50:58.918Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于 okhttp">
<meta name="twitter:description" content="简单使用Http Get12345678910111213141516171819OkhttpClient mOkHttpClient = new OkHttpClient();final Request request = new Request.Builder()    .url(&quot;https://www.baidu.com&quot;)    .build(); //可设置更多的参数：header、m">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/7866586-db6c625e9fa03ae0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>关于 okhttp</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/04/02/关于-RxJava/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/04/06/关于-okhttp/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/04/06/关于-okhttp/&text=关于 okhttp"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/04/06/关于-okhttp/&is_video=false&description=关于 okhttp"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于 okhttp&body=Check out this article: http://yoursite.com/2019/04/06/关于-okhttp/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/04/06/关于-okhttp/&name=关于 okhttp&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单使用"><span class="toc-number">1.</span> <span class="toc-text">简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Http-Get"><span class="toc-number">1.1.</span> <span class="toc-text">Http Get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http-Post-携带参数"><span class="toc-number">1.2.</span> <span class="toc-text">Http Post 携带参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于-Http-的文件上传"><span class="toc-number">1.3.</span> <span class="toc-text">基于 Http 的文件上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-number">1.4.</span> <span class="toc-text">封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本流程"><span class="toc-number">2.1.</span> <span class="toc-text">基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-OkHttpClient"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.OkHttpClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Request"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.Request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-异步请求"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.异步请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-同步请求"><span class="toc-number">2.1.4.</span> <span class="toc-text">4.同步请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RetryAndFollowUpInterceptor"><span class="toc-number">2.2.</span> <span class="toc-text">RetryAndFollowUpInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-宏观流程"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.宏观流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-过程细节"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.过程细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-总结"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheInterceptor"><span class="toc-number">2.3.</span> <span class="toc-text">CacheInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-宏观流程-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.宏观流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-过程细节-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.过程细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-总结-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">3 .总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConnectInterceptor"><span class="toc-number">2.4.</span> <span class="toc-text">ConnectInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CallServerInterceptor"><span class="toc-number">2.5.</span> <span class="toc-text">CallServerInterceptor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考引用其实就是照着打这样我会比较专注"><span class="toc-number">3.</span> <span class="toc-text">参考引用其实就是照着打这样我会比较专注</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        关于 okhttp
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Okkenok</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-04-06T14:48:37.000Z" itemprop="datePublished">2019-04-06</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Android-面试/">Android 面试</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="Http-Get"><a href="#Http-Get" class="headerlink" title="Http Get"></a>Http Get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">OkhttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">    .build(); <span class="comment">//可设置更多的参数：header、method 等</span></span><br><span class="line"></span><br><span class="line">Call call = mOkHttpClient.newCall(request);</span><br><span class="line"></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//String htmlStr = response.body().string();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>onResponse()</code>回调的参数是<code>response</code>，一般情况下，比如我们希望获得返回的字符串，可以通过<code>response.body().string()</code>获取；如果希望获取返回的二进制数据，则调用<code>response.body().bytes()</code>；如果你想拿到返回的<code>inputStream</code>，则调用<code>response.body().byteStream()</code></li>
<li><code>onResponse()</code>执行的线程并不是 UI 线程。</li>
<li>异步：<code>call.enqueue()</code>；同步：<code>call.execute()</code></li>
</ul>
<h3 id="Http-Post-携带参数"><a href="#Http-Post-携带参数" class="headerlink" title="Http Post 携带参数"></a>Http Post 携带参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Request request = buildMultipartFormRequest(url, <span class="keyword">new</span> File[]&#123;file&#125;, <span class="keyword">new</span> String[]&#123;fileKey&#125;, <span class="keyword">null</span>);</span><br><span class="line">FormEncodingBuilder builder = <span class="keyword">new</span> FormEncodingBuilder();</span><br><span class="line">builder.add(<span class="string">"username"</span>, <span class="string">"K"</span>);</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .post(builder.build())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback()&#123;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="基于-Http-的文件上传"><a href="#基于-Http-的文件上传" class="headerlink" title="基于 Http 的文件上传"></a>基于 Http 的文件上传</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(), <span class="string">"test.mp4"</span>);</span><br><span class="line"></span><br><span class="line">RequestBody fileBody = RequestBody.create(MediaType.parse(<span class="string">"application/octet-stream"</span>), file);</span><br><span class="line"></span><br><span class="line">RequestBoty requestBody = <span class="keyword">new</span> MultipartBuilder()</span><br><span class="line">    .type(MultipartBuilder.FORM)</span><br><span class="line">    .addPart(Headers.of(<span class="string">"Content-Disposition"</span>, <span class="string">"form-data; name=\"usrename\""</span>),RequestBody.create(<span class="keyword">null</span>, <span class="string">"L"</span>))</span><br><span class="line">    .addPart(Headers.of(<span class="string">"Content-Disposition"</span>, <span class="string">"form-data; name=\"mFile\";filename=\"test.mp4\""</span>), fileBody)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"fileUploadApi"</span>)</span><br><span class="line">    .post(requestBody)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Call call = mOkHttpClient.newCall(request);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener">okhttputils</a></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><h4 id="1-OkHttpClient"><a href="#1-OkHttpClient" class="headerlink" title="1.OkHttpClient"></a>1.<code>OkHttpClient</code></h4><ul>
<li><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient(Builder builder) &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Builder 模式：通过<code>Builder</code>配置参数，最后通过<code>build()</code>方法返回一个<code>OkHttpClient</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>从<code>OkHttpClient</code>中可以看出什么设计模式？Builder 模式、外观模式</p>
</blockquote>
<h4 id="2-Request"><a href="#2-Request" class="headerlink" title="2.Request"></a>2.<code>Request</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Request(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">    <span class="keyword">this</span>.method = builder.method;</span><br><span class="line">    <span class="keyword">this</span>.headers = builder.headers.build();</span><br><span class="line">    <span class="keyword">this</span>.body = builder.body;</span><br><span class="line">    <span class="keyword">this</span>.tag = builder.tag != <span class="keyword">null</span> ? builder.tag : <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这意味着什么，当构建一个<code>request</code>需要用<code>builder</code>模式进行构建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//builder===================</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.method = <span class="string">"GET"</span>;</span><br><span class="line">      <span class="keyword">this</span>.headers = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Builder(Request request) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = request.url;</span><br><span class="line">      <span class="keyword">this</span>.method = request.method;</span><br><span class="line">      <span class="keyword">this</span>.body = request.body;</span><br><span class="line">      <span class="keyword">this</span>.tag = request.tag;</span><br><span class="line">      <span class="keyword">this</span>.headers = request.headers.newBuilder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>request</code>的构建也是基于 Builder 模式。</p>
<h4 id="3-异步请求"><a href="#3-异步请求" class="headerlink" title="3.异步请求"></a>3.异步请求</h4><p>构建完<code>Request</code>后，接着构建一个<code>Call</code>，即<code>Call call = mOkHttpClient.newCall(request);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span>, <span class="title">WebSocket</span>.<span class="title">Factory</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从接口源码可以看出这个接口并不复杂，仅仅是定义一个<code>newCall</code>用于创建<code>Call</code>的方法，这里其实用到了<strong>工厂模式</strong>的思想，<strong>将构建的细节交给具体实现，顶层只需要拿到<code>Call</code>对象即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call); <span class="comment">//监听事件流程，使用了工厂模式</span></span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    <span class="comment">//默认创建一个retryAndFollowUpInterceptor过滤器</span></span><br><span class="line">    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>Call</code>创建完了，一般就到最后一个步骤，将请求加入调度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> Callback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>调用了<code>call</code>的<code>enqueue()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 防止多线程同时调用</span></span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace(); <span class="comment">//追踪堆栈信息</span></span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>); <span class="comment">//这是干吗的啊???回调？！</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>client.dispatcher().enqueue(new AsyncCall(responseCallback));</code>这里我们需要先回到<code>OkHttpClient</code>的源码中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dispatcher <span class="title">dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先对<code>Dispatcher</code>的成员变量做个初步的认识：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Ready async calls in the order they'll be run. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故上面的逻辑就可以比较清楚了。当正在执行的异步队列个数小于<code>maxRequest(64)</code>并且请求同一个主机的个数小于<code>maxRequestsPerHost(5)</code>时，则将这个请求加入异步执行队列<code>runningAsyncCall</code>，并用线程池执行这个<code>Call</code>，否则加入异步等待队列。</p>
<p>现在来看一个<code>AsyncCall</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所以这一系列的操作的作用是？</span></span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>NamedRunnable</code>是一个抽象类，实现了<code>Runnable</code>接口。这里将当前执行的线程的名字设为我们在构造方法中传入的名字，接着执行<code>execute()</code>方法，<code>finally</code>再设置回来。回到<code>AsyncCall</code>中找到<code>execute()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，找到了<strong>Response</strong>的身影了，那么就意味着执行网络请求就在<code>getResponseWithInterceptorChain()</code>中，后面的代码其实基本上就是一些接口回调，回调当前<code>Call</code>的执行状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor); <span class="comment">//失败和重定向过滤器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar())); <span class="comment">//封装request和response过滤器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache())); <span class="comment">//缓存相关过滤器，负责读取缓存直接返回、更新缓存</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client)); <span class="comment">//负责和服务器建立连接</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      <span class="comment">//配置OkHttpClient时设置的networkInterceptors</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//负责向服务器发送请求数据、从服务器读取响应数据（实际网络请求）</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各式各样的<code>Interceptor</code>的列表。当我们默认创建<code>OkHttpClient</code>时，<code>okHttp</code>默认会给我们实现这些过滤器，每个过滤器执行不同的任务，各个过滤器间相互不耦合。</p>
<blockquote>
<p>retryAndFollowUpInterceptor——失败和重定向过滤器<br>BridgeInterceptor——封装request和response过滤器<br>CacheInterceptor——缓存相关的过滤器，负责读取缓存直接返回、更新缓存<br>ConnectInterceptor——负责和服务器建立连接，连接池等<br>networkInterceptors——配置 OkHttpClient 时设置的 networkInterceptors<br>CallServerInterceptor——负责向服务器发送请求数据、从服务器读取响应数据(实际网络请求)</p>
</blockquote>
<p>添加完过滤器后，就是执行过滤器了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">    originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">    client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> chain.proceed(originalRequest);</span><br></pre></td></tr></table></figure>
<p>可以看到这里创建了一个<code>RealInterceptorChain</code>，并调用了<code>proceed()</code>，这里注意下<code>index:0</code>这个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A concrete interceptor chain that carries the entire interceptor chain: all application</span></span><br><span class="line"><span class="comment"> * interceptors, the OkHttp core, all network interceptors, and finally the network caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>RealInterceptorChain</code>就是所有过滤器组成的调用链，最终的网络请求动作也是由它发起的。我们看看它的<code>proceed()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next); <span class="comment">//这里调用的就是特定过滤器实现Interceptor接口的自身的intercept方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>index</code>从<code>0</code>开始，如果<code>index</code>超过了过滤器的个数会抛出异常，后面会<code>new</code>一个<code>RealInterceptorChain</code>，而且会将参数传递，并且<code>index + 1</code>了，接着获取<code>index</code>的<code>interceptor</code>，并调用了<code>intercept()</code>，传入新<code>new</code>的<code>next</code>对象。这里用了<strong>递归</strong>的思想来完成遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里我们拿了一个<code>ConnectInterceptor</code>的源码，这里得到<code>Chain</code>后，进行相应的处理后，继续调用<code>proceed()</code>,那么就接着刚才的逻辑，<code>index + 1</code>，获取下一个<code>Interceptor</code>，重复操作，所以现在就很清楚了，这里利用<strong>递归循环</strong>，也就是 OkHttp 最经典的<strong>责任链模式</strong>。</p>
<h4 id="4-同步请求"><a href="#4-同步请求" class="headerlink" title="4.同步请求"></a>4.同步请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  eventListener.callStart(<span class="keyword">this</span>); <span class="comment">//回调</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>); <span class="comment">//将请求加入同步队列中</span></span><br><span class="line">    Response result = getResponseWithInterceptorChain(); <span class="comment">//创建过滤器责任链，得到 Response</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到基本上流程都一致，除了是同步执行，核心方法走的还是<code>getResponseWithInterceptorChain()</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7866586-db6c625e9fa03ae0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="okHttp流程"></p>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><h4 id="1-宏观流程"><a href="#1-宏观流程" class="headerlink" title="1.宏观流程"></a>1.宏观流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    。。。</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span>(满足条件)&#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">      <span class="comment">//不满足条件，一顿操作，赋值再来！</span></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>宏观流程，循环体里面的主要方法就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>执行了这个方法，就会交给下一个过滤器继续执行，所以单从这里来看，我们可以简单的理解这个过滤器其实没有做什么。</p>
<p>但是当出现了一些问题，导致不满足条件的时候，就需要进行一系列的操作，重新复制<code>Request</code>，重新请求，这也就是<code>while</code>的功能，对应的也就是这个过滤器的主要功能：<strong>重试和重定向</strong>。</p>
<h4 id="2-过程细节"><a href="#2-过程细节" class="headerlink" title="2.过程细节"></a>2.过程细节</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Request request = chain.request();</span><br><span class="line">   RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">   Call call = realChain.call();</span><br><span class="line">   EventListener eventListener = realChain.eventListener();</span><br><span class="line"><span class="comment">//StreamAllocation 的作用：协调 Calls、Streams、Connections 三者的关系</span></span><br><span class="line">   StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">       createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">   <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">   Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (canceled) &#123; <span class="comment">//请求已取消</span></span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Response response;</span><br><span class="line">     <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//执行请求</span></span><br><span class="line">       response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">       <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">       <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">           <span class="comment">// 判断能否从前一个请求恢复，不行就抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">       &#125;</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//重试</span></span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">         <span class="comment">// 先判断当前请求是否已经发送了</span></span><br><span class="line">       <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">         <span class="comment">// 同样的重试判断</span></span><br><span class="line">       <span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">continue</span>; <span class="comment">//重试</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">         <span class="comment">// 没有捕获到的异常，最终要释放</span></span><br><span class="line">       <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">         streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">       <span class="comment">//priorResponse 是用来保存前一个 Response 的，这里可以看到将前一个Response和当前Response结合到一起了，</span></span><br><span class="line">       <span class="comment">//对应的场景是，当获得Response后，发现需要重定向，则将当前Response设置给priorResponse，再执行一遍流程，</span></span><br><span class="line">       <span class="comment">//直到不需要重定向了，则将priorResponse和Response结合起来。</span></span><br><span class="line">     <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">       response = response.newBuilder()</span><br><span class="line">           .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                   .body(<span class="keyword">null</span>)</span><br><span class="line">                   .build())</span><br><span class="line">           .build();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//判断是否需要重定向，如果需要重定向则返回一个重定向的Request，没有则为null</span></span><br><span class="line">     Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123; <span class="comment">//不需要重定向</span></span><br><span class="line">       <span class="keyword">if</span> (!forWebSocket) &#123; <span class="comment">//是WebSocket，释放</span></span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     closeQuietly(response.body()); <span class="comment">//需要重定向，关闭响应流</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//重定向次数++，并且小于最大重定向次数 MAX_FOLLOW_UPS (20)</span></span><br><span class="line">     <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//流类型，没有被缓存，不能重定向</span></span><br><span class="line">     <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">     &#125;</span><br><span class="line">	<span class="comment">//判断是否相同，不然重新创建一个streamConnection</span></span><br><span class="line">     <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">           createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">       <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">           + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//赋值再来</span></span><br><span class="line">     request = followUp;</span><br><span class="line">     priorResponse = response;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StreamAllocation 的作用：协调 Calls、Streams、Connections 三者的关系</span></span><br><span class="line">    StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br></pre></td></tr></table></figure>
<p>这个类大概可以理解为是处理<code>Connections</code>，<code>Streams</code>，<code>Calls</code>三者的关系，这一点其实从构造函数的传参也可以看出来。</p>
<p>接下来就要进入循环体中看了，首先可以看到当请求被取消的时候，会跳出循环体（第一种跳出的情况）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Response response;</span><br><span class="line">     <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//执行请求</span></span><br><span class="line">       response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">       <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">       <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">           <span class="comment">// 判断能否从前一个请求恢复，不行就抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">       &#125;</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//重试</span></span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>接下来看<code>try catch</code>体中的内容，<code>try</code>其实就是执行后续过滤器链中的东西，这里要稍微注意一下<code>releaseConnection</code>这个变量的，对后续的判断理解是有影响的，可以看到初始化时将<code>releaseConnection</code>这个变量赋值为<code>true</code>。</p>
<p>下面是重点内容了：</p>
<p>看到捕获的第一个异常<code>RouteException</code>，注释为<strong>尝试连接一个路由失败，这个请求还没有被发出</strong>，接下来执行了一个方法<code>recover()</code>，这里注意一下<code>false</code>参数，进入到方法体中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(IOException e, <span class="keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;</span><br><span class="line">  streamAllocation.streamFailed(e);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The application layer has forbidden retries.</span></span><br><span class="line">    <span class="comment">// 如果OkHttpClient直接配置拒绝失败重连</span></span><br><span class="line">    <span class="comment">// 默认创建的OkHttpClient的retryOnConnectionFailure属性是true</span></span><br><span class="line">  <span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can't send the request body again.</span></span><br><span class="line">    <span class="comment">//如果请求已经发送，并且这个请求体是一个UnrepeatableRequestBody类型，则不能重试</span></span><br><span class="line">    <span class="comment">//StreamedRequestBody实现了UnrepeatableRequestBody接口，是个流类型，不会被缓存，所以只能执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (requestSendStarted &amp;&amp; userRequest.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This exception is fatal.</span></span><br><span class="line">    <span class="comment">//一些严重问题就不要重试了</span></span><br><span class="line">  <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No more routes to attempt.</span></span><br><span class="line">    <span class="comment">//没有更多的路由就不要重试了</span></span><br><span class="line">  <span class="keyword">if</span> (!streamAllocation.hasMoreRoutes()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个判断条件中，这个<code>UnrepeatableRequestBody</code>，是一个空的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnrepeatableRequestBody</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个空的接口的作用就是标记那些不能被重复请求的请求体，这个时候可能就要了解哪些请求是不能被重复请求的。<strong>到目前的 OkHttp 源码中，只有一种请求实现了这个接口，那就是 StreamedRequestBody</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a</span></span><br><span class="line"><span class="comment"> * pipe. Because the data is not buffered it can only be transmitted once.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamedRequestBody</span> <span class="keyword">extends</span> <span class="title">OutputStreamRequestBody</span> <span class="keyword">implements</span> <span class="title">UnrepeatableRequestBody</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从这个类的注释我们也可以理解，<code>StreameedRequestBody</code>实现了<code>UnrepeatableRequestBody</code>接口，是个流类型，不会被缓存，所以只能执行一次。</p>
<p>看看第三个判断条件，也就是<code>if(!isRecoverable(e, requestSendStarted)) return false;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRecoverable</span><span class="params">(IOException e, <span class="keyword">boolean</span> requestSendStarted)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If there was a protocol problem, don't recover.</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ProtocolException) &#123;<span class="comment">//如果是协议问题</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an interruption don't recover, but if there was a timeout connecting to a route</span></span><br><span class="line">    <span class="comment">// we should try the next route (if there is one).</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedIOException) &#123;<span class="comment">// 中断</span></span><br><span class="line">        <span class="comment">//超时问题并且请求还没有被发送，可以重试</span></span><br><span class="line">        <span class="comment">//其他就不要重试了</span></span><br><span class="line">      <span class="keyword">return</span> e <span class="keyword">instanceof</span> SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look for known client-side or negotiation errors that are unlikely to be fixed by trying</span></span><br><span class="line">    <span class="comment">// again with a different route.</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLHandshakeException) &#123;</span><br><span class="line">      <span class="comment">// If the problem was a CertificateException from the X509TrustManager,</span></span><br><span class="line">      <span class="comment">// do not retry.</span></span><br><span class="line">        <span class="comment">//证书或安全原因。就不要重试</span></span><br><span class="line">      <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> CertificateException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">      <span class="comment">// e.g. a certificate pinning error.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An example of one we might want to retry with a different route is a problem connecting to a</span></span><br><span class="line">    <span class="comment">// proxy and would manifest as a standard IOException. Unless it is one we know we should not</span></span><br><span class="line">    <span class="comment">// retry, we return true and try a new route.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体可以理解为：如果是一些严重的问题（协议、安全……），拒绝重试。以上判断归结到一个<code>isRecoverable()</code>方法中，这里严重的情况主要由这几种：</p>
<ul>
<li>协议问题，不能重试；</li>
<li>超时问题，并且请求还没有被发送，可以重试，其他就不要重试了。</li>
<li>安全问题，不要重试。</li>
</ul>
<p>最后一个判断：<code>if(!streamAllocation.hasMoreRoutes()) return false;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreRoutes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> route != <span class="keyword">null</span> || routeSelector.hasNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if there's another route to attempt. Every address has at least one route.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hasNextInetSocketAddress()</span><br><span class="line">      || hasNextProxy()</span><br><span class="line">      || hasNextPostponed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个判断表明：没有更多的可以使用的路由，则不要重试了（第四种拒绝重连的方式）。这里大概说明一下<strong>routeSelection 是用 List 保存的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//重试。。。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以当上述判断结束后，如果需要重试，则<code>continue</code>，重新执行循环体，也就是发挥了这个过滤器的作用，<strong>重试</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="comment">//先判断当前请求是否已经发送了</span></span><br><span class="line">        <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">        <span class="comment">//同样的重试判断</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//重试。。。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候查看下一个异常<code>IOException</code>，这里稍微注意下<code>requestSendStarted</code>，先前版本的出现的<a href="https://blog.imallen.wang/2017/08/30/%E4%B8%80%E4%B8%AAOkHttp%E7%9A%84bug%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/" target="_blank" rel="noopener">循环重复请求问题</a>。这时默认传的就不是<code>false</code>，而是判断得到的<code>requestSendStarted</code>。最后同样当需要重试时，继续循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">        <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">            <span class="comment">//没有捕获到异常，最终要释放。</span></span><br><span class="line">          streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(<span class="keyword">null</span>)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><code>priorResponse</code>是用来保存前一个<code>Response</code>的，这里可以看到将前一个<code>Response</code>和当前<code>Response</code>结合在一起了。对应的场景是：<strong>当获得<code>Response</code>后，发现需要重定向，则将当前<code>Response</code>设置给<code>priorResponse</code>，再执行一遍流程，直到不需要重定向了，则将<code>priorResponse</code>和<code>Response</code>结合起来</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">      Request followUp = followUpRequest(response);</span><br><span class="line"><span class="comment">//=========================followUpRequest()==============================</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Figures out the HTTP request to make in response to receiving &#123;<span class="doctag">@code</span> userResponse&#125;. This will</span></span><br><span class="line"><span class="comment">   * either add authentication headers, follow redirects or handle a client request timeout. If a</span></span><br><span class="line"><span class="comment">   * follow-up is either unnecessary or not applicable, this returns null.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Request <span class="title">followUpRequest</span><span class="params">(Response userResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    Connection connection = streamAllocation.connection();</span><br><span class="line">    Route route = connection != <span class="keyword">null</span></span><br><span class="line">        ? connection.route()</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String method = userResponse.request().method();</span><br><span class="line">    <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">      <span class="keyword">case</span> HTTP_PROXY_AUTH:</span><br><span class="line">        Proxy selectedProxy = route != <span class="keyword">null</span></span><br><span class="line">            ? route.proxy()</span><br><span class="line">            : client.proxy();</span><br><span class="line">        <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> HTTP_UNAUTHORIZED:</span><br><span class="line">        <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> HTTP_PERM_REDIRECT:</span><br><span class="line">      <span class="keyword">case</span> HTTP_TEMP_REDIRECT:</span><br><span class="line">        <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">        <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">        <span class="keyword">if</span> (!method.equals(<span class="string">"GET"</span>) &amp;&amp; !method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fall-through</span></span><br><span class="line">      <span class="keyword">case</span> HTTP_MULT_CHOICE:</span><br><span class="line">      <span class="keyword">case</span> HTTP_MOVED_PERM:</span><br><span class="line">      <span class="keyword">case</span> HTTP_MOVED_TEMP:</span><br><span class="line">      <span class="keyword">case</span> HTTP_SEE_OTHER:</span><br><span class="line">        <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">        <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String location = userResponse.header(<span class="string">"Location"</span>);</span><br><span class="line">        <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">        <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">        <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Most redirects don't include a request body.</span></span><br><span class="line">        Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">          <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">            requestBuilder.method(<span class="string">"GET"</span>, <span class="keyword">null</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">            requestBuilder.method(method, requestBody);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">        <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">        <span class="comment">// way to retain them.</span></span><br><span class="line">        <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">          requestBuilder.removeHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//重新构造了一个 Request</span></span><br><span class="line">        <span class="keyword">return</span> requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</span><br><span class="line">        <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></span><br><span class="line">        <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></span><br><span class="line">        <span class="comment">// repeat the request (even non-idempotent ones.)</span></span><br><span class="line">        <span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userResponse.request();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面这行代码主要是对<code>followUpRequest()</code>这个方法的理解，其实没必要在意每一行代码，这样反而会影响我们的阅读。这里可以观察发现，其实这个方法的主要操作是，<strong>当返回码满足某些条件时就重新构造一个<code>Request</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(followUp == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//不需要重定向</span></span><br><span class="line">    <span class="keyword">if</span>(!forWebSocket)&#123;</span><br><span class="line">        <span class="comment">//是WebSocket，释放</span></span><br><span class="line">        streamAllocation.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当不需要重定向，也就是返回<code>null</code>，直接返回<code>response</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        streamAllocation = <span class="keyword">new</span> StreamAllocation(</span><br><span class="line">            client.connectionPool(), createAddress(followUp.url()), callStackTrace);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">            + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br></pre></td></tr></table></figure>
<p>当返回的不为空，也就是重新构造了一个<code>Request</code>，需要重定向。</p>
<ol>
<li>关闭响应流；<code>closeQuietly(response.body());</code></li>
<li>增加重定向的次数，保证小于最大重定向次数；<code>++followUpCount &gt; MAX_FOLLOW_UPS</code></li>
<li>不能是<code>UnrepeatableRequestBody</code>类型，这是一个空接口，用于标记那些只能请求一次的请求；</li>
<li>判断是否相同，如果不相同，则需要重新创建一个<code>streamConnection</code>。</li>
<li>重新赋值，结束当前循环，继续<code>while</code>循环，也就是执行重定向请求。</li>
</ol>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p>这个过滤器主要作用就是用于对请求的重试和重定向的。其中拒绝重试的判断条件有如下几种：</p>
<ul>
<li>在配置<code>OkHttpClient</code>中配置<code>retryOnConnectionFailure</code>属性为<code>false</code>，表明拒绝失败重连，那么这里返回<code>false</code></li>
<li>如果请求已经发送，并且这个请求体是一个<code>UnrepeatableRequestBody</code>类型，则不能重试</li>
<li>如果是一些严重的问题（协议，安全等），拒绝重试</li>
<li>没有更多可以使用的路由，则不要重试了</li>
</ul>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><h4 id="1-宏观流程-1"><a href="#1-宏观流程-1" class="headerlink" title="1.宏观流程"></a>1.宏观流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1 尝试通过这个Request拿到缓存</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//2如果不允许使用网络并且缓存为空，新建一个504的Response返回</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3如果不允许使用网络，但是有缓存，返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4链式调用下一个过滤器</span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    <span class="comment">//5如果缓存不为空，但是网络请求得来的返回码是304</span></span><br><span class="line">    <span class="comment">//(如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供`If-Modified-Since`头表示客户只想指定日期更新文档）。)</span></span><br><span class="line">    <span class="comment">//服务器告诉客户，原来缓冲的文档还可以继续使用，则使用缓存的响应</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6 使用网络请求得到的Response</span></span><br><span class="line">    Response response = networkResponse;</span><br><span class="line">    <span class="comment">//7并将这个Response缓存起来（前提当然是能缓存）</span></span><br><span class="line">    cache.put(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-过程细节-1"><a href="#2-过程细节-1" class="headerlink" title="2.过程细节"></a>2.过程细节</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">       ? cache.get(chain.request())</span><br><span class="line">       : <span class="keyword">null</span>; <span class="comment">//默认cache为null，可以在构建okHttpClient时配置cache，不为空时尝试获取缓存中的response</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//根据response，time，request创建一个缓存策略，用于判断怎样是使用缓存</span></span><br><span class="line">   CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">   Request networkRequest = strategy.networkRequest;</span><br><span class="line">   Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">     cache.trackResponse(strategy);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">     closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">     <span class="comment">//如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个response直接返回，注意返回码为504</span></span><br><span class="line">   <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">         .request(chain.request())</span><br><span class="line">         .protocol(Protocol.HTTP_1_1)</span><br><span class="line">         .code(<span class="number">504</span>)</span><br><span class="line">         .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">         .body(Util.EMPTY_RESPONSE)</span><br><span class="line">         .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">     <span class="comment">//如果不使用网络，但是又缓存，直接返回缓存</span></span><br><span class="line">   <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">         .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       直接走后续过滤器</span><br><span class="line">     networkResponse = chain.proceed(networkRequest);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">     <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">       closeQuietly(cacheCandidate.body());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">     <span class="comment">//当缓存响应和网络响应同时存在的时候，选择用哪个</span></span><br><span class="line">   <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">         <span class="comment">//如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求</span></span><br><span class="line">         <span class="comment">//（一般是提供If-Modified-Since头表示用户只想到指定日期更新文档）</span></span><br><span class="line">         <span class="comment">//服务器告诉客户，原来缓冲的文档还可以继续使用</span></span><br><span class="line">         <span class="comment">//则使用缓存的响应</span></span><br><span class="line">       Response response = cacheResponse.newBuilder()</span><br><span class="line">           .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">           .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">           .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">           .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">           .networkResponse(stripBody(networkResponse))</span><br><span class="line">           .build();</span><br><span class="line">       networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">       <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">       cache.trackConditionalCacheHit();</span><br><span class="line">       cache.update(cacheResponse, response);</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       closeQuietly(cacheResponse.body());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//使用网络响应</span></span><br><span class="line">   Response response = networkResponse.newBuilder()</span><br><span class="line">       .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">       .networkResponse(stripBody(networkResponse))</span><br><span class="line">       .build();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//所以默认创建的OkHttpClient是没有缓存的</span></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//将响应缓存</span></span><br><span class="line">     <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">       <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">         <span class="comment">//缓存Response的Header信息</span></span><br><span class="line">       CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">         <span class="comment">//缓存Body</span></span><br><span class="line">       <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">     &#125;</span><br><span class="line">	<span class="comment">//只能缓存GET，不然移除request</span></span><br><span class="line">     <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         cache.remove(networkRequest);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">         <span class="comment">// The cache cannot be written.</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> response;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先看第一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">    ? cache.get(chain.request())</span><br><span class="line">    : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>这里的重点就是要看<strong>怎么取缓存</strong>了。其实<code>CacheInterceptor</code>重点比较难以理解的就是：<strong>拿缓存，缓存策略，存缓存</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> InternalCache cache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(InternalCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//======================RealCall.java======================</span></span><br><span class="line">interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br></pre></td></tr></table></figure>
<p>首先可以看到这里的<code>cache</code>是<code>InternalCache</code>类型，而且是在构造函数的时候调用的。并且通过<code>RealCall</code>也可以看到，构造这个过滤器的时候传入的是我们构造<code>OkHttpClient</code>中设置的<code>internalCache</code>，<strong>而当我们用默认方式构造<code>OKHttpClient</code>时是不会创建缓存的，也就是<code>internalCache = null</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OkHttp's internal cache interface. Applications shouldn't implement this: instead use &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * okhttp3.Cache&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InternalCache</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove any cache entries for the supplied &#123;<span class="doctag">@code</span> request&#125;. This is invoked when the client</span></span><br><span class="line"><span class="comment">   * invalidates the cache, such as when making POST requests.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Handles a conditional request hit by updating the stored cache response with the headers from</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> network&#125;. The cached response body is not updated. If the stored response has changed</span></span><br><span class="line"><span class="comment">   * since &#123;<span class="doctag">@code</span> cached&#125; was returned, this does nothing.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Track an conditional GET that was satisfied by this cache. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Track an HTTP response being satisfied with &#123;<span class="doctag">@code</span> cacheStrategy&#125;. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不出意外，<code>InternalCache</code>是一个接口，<code>OkHttp</code>充分贯彻了<strong>面向接口编程</strong>。接着查找<code>OkHttp</code>中哪个实现了或者说使用了这个接口，对应找到了<code>Cache</code>这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">final</span> InternalCache internalCache = <span class="keyword">new</span> InternalCache() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Cache.<span class="keyword">this</span>.get(request);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">  &#125;;</span><br><span class="line">    ...</span><br><span class="line">  <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    String key = key(request.url());</span><br><span class="line">    DiskLruCache.Snapshot snapshot;</span><br><span class="line">    Entry entry;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      snapshot = cache.get(key);</span><br><span class="line">      <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//没拿到，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Give up because the cache cannot be read.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Entry，这里其实传入的是CleanFiles数组的第一个（ENTRY_METADATA = 0）</span></span><br><span class="line">        <span class="comment">//得到的是头信息，也就是key.0</span></span><br><span class="line">      entry = <span class="keyword">new</span> Entry(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      Util.closeQuietly(snapshot);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//得到缓存构建得到的response</span></span><br><span class="line">    Response response = entry.response(snapshot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry.matches(request, response)) &#123;</span><br><span class="line">      Util.closeQuietly(response.body());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Cache</code>中实现了<code>InternalCache</code>这个接口，<code>get()</code>方法对应调用的是<code>Cache</code>类中的<code>get()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String key = key(request.url());</span><br></pre></td></tr></table></figure>
<p>缓存的<code>key</code>是和<code>request</code>的<code>url</code>直接相关的。这里通过<code>url</code>，得到了缓存的<code>key</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final DiskLruCache cache;</span><br><span class="line">==============================</span><br><span class="line">DiskLruCache.Snapshot snapshot;</span><br><span class="line">    Entry entry;</span><br><span class="line">    try &#123;</span><br><span class="line">      snapshot = cache.get(key);</span><br><span class="line">      if (snapshot == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      // Give up because the cache cannot be read.</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>刚开始看到对各种变量是很难理解的，可以看到这里得到<code>key</code>后，又会走<code>cache.get()</code>方法。首先要明白的是，这里的<code>cache</code>对应的类型是<code>DiskLruCache</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't exist is not currently</span></span><br><span class="line"><span class="comment"> * readable. If a value is returned, it is moved to the head of the LRU queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  initialize();<span class="comment">//总结来说就是对journalFile文件的操作，有则删除无用冗余的信息，构建新文件，没有则new一个新的</span></span><br><span class="line"></span><br><span class="line">  checkNotClosed();<span class="comment">//判断是否关闭，如果缓存损坏了，则会被关闭</span></span><br><span class="line">  validateKey(key);<span class="comment">//检查key是否满足格式要求，正则表达式</span></span><br><span class="line">  Entry entry = lruEntries.get(key);<span class="comment">//获取key对应的Entry</span></span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span> || !entry.readable) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  Snapshot snapshot = entry.snapshot();<span class="comment">//获取Entry里面的snapshot的值</span></span><br><span class="line">  <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;<span class="comment">//有则计数器加1</span></span><br><span class="line">  journalWriter.writeUtf8(READ).writeByte(<span class="string">' '</span>).writeUtf8(key).writeByte(<span class="string">'\n'</span>);<span class="comment">//把这个内容写入文档中</span></span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;<span class="comment">//判断是否达清理条件</span></span><br><span class="line">    executor.execute(cleanupRunnable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> snapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入到<code>DisLruCache</code>内部，首先执行的是<code>initialize()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>); <span class="comment">//断言，当持有自己锁的时候，继续执行。没有持有锁，抛出异常</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// Already initialized.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a bkp file exists, use it instead.</span></span><br><span class="line">  <span class="keyword">if</span> (fileSystem.exists(journalFileBackup)) &#123;</span><br><span class="line">    <span class="comment">// If journal file also exists just delete backup file.</span></span><br><span class="line">    <span class="keyword">if</span> (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">      fileSystem.delete(journalFileBackup);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fileSystem.rename(journalFileBackup, journalFile);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//经过上述判断后的结果只有两种：1.什么都没有；2.有journalFile文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prefer to pick up where we left off.</span></span><br><span class="line">  <span class="keyword">if</span> (fileSystem.exists(journalFile)) &#123;<span class="comment">//journalFile文件动作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      readJournal();</span><br><span class="line">      processJournal();</span><br><span class="line">      initialized = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">      Platform.get().log(WARN, <span class="string">"DiskLruCache "</span> + directory + <span class="string">" is corrupt: "</span></span><br><span class="line">          + journalIsCorrupt.getMessage() + <span class="string">", removing"</span>, journalIsCorrupt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span></span><br><span class="line">    <span class="comment">// we'll let that propagate out as it likely means there is a severe filesystem problem.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      delete();<span class="comment">//到了这里表示有缓存损坏导致异常，则删除缓存目录下所有文件</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rebuildJournal();<span class="comment">//如果没有journalFile则重建一个</span></span><br><span class="line"></span><br><span class="line">  initialized = <span class="keyword">true</span>;<span class="comment">//标记初始化完成，无论有没有journalFile文件。initialized都会标记为true，只执行一遍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先说明一下<strong><code>journalFile</code>指的是日志文件，是对缓存一系列操作的记录，不影响缓存的执行流程。</strong>可以看到这里有两个文件<code>journalFile</code>和<code>journalFileBackup</code>，从名字上可以确定，一个是备份文件，一个是记录文件，随着后面的分析，会发现缓存中充分利用这两个文件，这种形式，一个用于保存，一个用于编辑操作。</p>
<p>当存在<code>journalFile</code>，执行<code>readHournal()</code>，读取<code>journalFile</code>文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedSource source = Okio.buffer(fileSystem.source(journalFile)); <span class="comment">//利用Okio读取journalFile文件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String magic = source.readUtf8LineStrict();</span><br><span class="line">      String version = source.readUtf8LineStrict();</span><br><span class="line">      String appVersionString = source.readUtf8LineStrict();</span><br><span class="line">      String valueCountString = source.readUtf8LineStrict();</span><br><span class="line">      String blank = source.readUtf8LineStrict();</span><br><span class="line">        <span class="comment">//保证和默认值相同</span></span><br><span class="line">      <span class="keyword">if</span> (!MAGIC.equals(magic)</span><br><span class="line">          || !VERSION_1.equals(version)</span><br><span class="line">          || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">          || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">          || !<span class="string">""</span>.equals(blank)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal header: ["</span> + magic + <span class="string">", "</span> + version + <span class="string">", "</span></span><br><span class="line">            + valueCountString + <span class="string">", "</span> + blank + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//逐行读取，并根据每行的开头，不同的状态执行不同的操作，主要就是往LruEntries里面add，或者remove </span></span><br><span class="line">          readJournalLine(source.readUtf8LineStrict());</span><br><span class="line">          lineCount++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//日志操作的记录数 = 总行数 - lruEntries 中实际add的行数  </span></span><br><span class="line">      redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we ended on a truncated line, rebuild the journal before appending to it.</span></span><br><span class="line">      <span class="keyword">if</span> (!source.exhausted()) &#123;<span class="comment">//表示是否还多余字节。如果没有多余字节，返回true，有多余字节返回false</span></span><br><span class="line">        rebuildJournal();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        journalWriter = newJournalWriter();<span class="comment">//获取这个文件的Sink，以便Writer</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Util.closeQuietly(source);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里用到了使用<code>OkHttp</code>必须依赖的库<code>Okio</code>，这个库内部对输入输出流进行了很多优化，分帧读取写入，帧还有池的概念。具体原理可以网上去学习。</p>
<p>看一下<code>readJournalLine()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> firstSpace = line.indexOf(<span class="string">' '</span>);<span class="comment">//记录第一个空串的位置</span></span><br><span class="line">  <span class="keyword">if</span> (firstSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> keyBegin = firstSpace + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> secondSpace = line.indexOf(<span class="string">' '</span>, keyBegin);<span class="comment">//记录第二个空串的位置</span></span><br><span class="line">  <span class="keyword">final</span> String key;</span><br><span class="line">  <span class="keyword">if</span> (secondSpace == -<span class="number">1</span>) &#123;<span class="comment">//如果中间没有空串，则直接截取得到key</span></span><br><span class="line">    key = line.substring(keyBegin);</span><br><span class="line">    <span class="keyword">if</span> (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;<span class="comment">//如果解析出来的是“REMOVE sjkafjlasj”这样以REMOVE开头的</span></span><br><span class="line">      lruEntries.remove(key);<span class="comment">//移除这个key, LruEntries是LinkedHashMap</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//解析两个空格间的字符串为key</span></span><br><span class="line">    key = line.substring(keyBegin, secondSpace);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Entry entry = lruEntries.get(key);<span class="comment">//取出Entry对象</span></span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果Entry对象为空，则new一个Entry，把key,和对象put进去</span></span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (secondSpace != -<span class="number">1</span> &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">      <span class="comment">//如果是“CLEAN 1 2”这样的以CLEAN开头</span></span><br><span class="line">      <span class="comment">//取第二个空格后面的字符串，parts变成[1,2]</span></span><br><span class="line">    String[] parts = line.substring(secondSpace + <span class="number">1</span>).split(<span class="string">" "</span>);</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;<span class="comment">//可读</span></span><br><span class="line">    entry.currentEditor = <span class="keyword">null</span>;<span class="comment">//不被编辑</span></span><br><span class="line">    entry.setLengths(parts);<span class="comment">//设置长度</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">      <span class="comment">//如果是“DIRTY dsfjkfj”这样以DIRTY开头，新建一个Editor</span></span><br><span class="line">    entry.currentEditor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">    <span class="comment">// This work was already done by calling lruEntries.get().</span></span><br><span class="line">      <span class="comment">//如果是“READ sfkjskf”这样以READ开头，不需要做什么事</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一开始可能比较难以理解，说明一下<code>journalFile</code>每一行的保存格式是这样的：</p>
<p><strong>REMOVE sdkjlg 2341 1234</strong></p>
<p>第一个空格前面代表这条日志的操作内容，后面的第一个保存的是 key，后面这两个内容根据前面的操作存入缓存内容对应的 length。如果没有空格，那么数据格式就是这样的：<strong>REMOVE sdjkhf</strong>，截取第一个空格之后的内容为 key，如果是以 REMOVE 开头，则从<code>lruEntries</code>移除这个 key 对应的缓存。如果有第二个空格，如上，则去第一个空格和第二个空格间取内容作为 key。如果是类似：<strong>CLEAN jsdf 2 5</strong>，以 CLEAN 开头的话，则将取出 key 后面的数组，设置可读不可编辑。并设置 entry 的长度。这里先说明一下 Entry 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Lengths of this entry's files. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line">  <span class="keyword">final</span> File[] cleanFiles;<span class="comment">//用于保存持久数据，作用是读取，最后格式：key.0</span></span><br><span class="line">  <span class="keyword">final</span> File[] dirtyFiles;<span class="comment">//用于保存编辑的临时数据，作用是写，最后的格式：ley.0.tmp</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Entry 中又两个数组，<code>cleanFiles</code>是用于保存持久性数据。用于读取，<code>dirtyFiles</code>是用于进行编辑，当编辑完成后会执行<code>commit</code>操作，将<code>dirtyFiles</code>赋值给<code>cleanFiles</code>。<code>length</code>适用于保存 Entry 中每个数组对应的 file 的数量。</p>
<p>所以当 <strong>CLEAN jklsd 2 5</strong>，如果是以 CLEAN 开头的话，<code>cleanFiles</code>对应的 size 就是2，<code>dirtyFiles</code>对应的数量是 5（默认都是2个）。</p>
<p>后面的都类似。至此结束对<code>readJournalLine()</code>方法的分析，总结一下这个方法的作用：<strong>逐行读取，并根据每行的开头，不同的状态执行不同的操作，主要就是往<code>lruEntries</code>里面<code>add</code>，或者<code>remove</code>。接着返回到<code>readJournal()</code>方法中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//逐行读取，并根据每行的开头，不同的状态执行不同的操作，主要就是往lruEntries里面add，或者remove</span></span><br><span class="line">          readJournalLine(source.readUtf8LineStrict());</span><br><span class="line">          lineCount++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里利用<code>lineCount</code>记录读取的行数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志中操作的记录数=总行数-lruEntries中实际add的行数</span></span><br><span class="line">      redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line">      <span class="comment">//source.exhausted()表示是否还多余字节，如果没有多余字节，返回true，有多余字节返回false</span></span><br><span class="line">      <span class="comment">// If we ended on a truncated line, rebuild the journal before appending to it.</span></span><br><span class="line">      <span class="keyword">if</span> (!source.exhausted()) &#123;</span><br><span class="line">        <span class="comment">//如果有多余的字节，则重新构建下journal文件</span></span><br><span class="line">        rebuildJournal();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取这个文件的Sink,以便Writer</span></span><br><span class="line">        journalWriter = newJournalWriter();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>读取完毕后会计算日志中操作的记录数，日志中操作的记录数 = 读取的总行数 - lruEntries 中实际保存的行数。</p>
<p>接下来<code>source.exhausted()</code>是表示是否还多余字节，如果没有多余字节，返回<code>true</code>，有多余字节返回<code>false</code>，如果有多余的字节则需要执行<code>rebuildJournal()</code>，没有则获得这个文件的<code>Sink</code>，用于<code>Write</code>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates a new journal that omits redundant information. This replaces the current journal if it</span></span><br><span class="line"><span class="comment">  * exists.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (journalWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">     journalWriter.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//写入校验信息</span></span><br><span class="line">     writer.writeUtf8(MAGIC).writeByte(<span class="string">'\n'</span>);</span><br><span class="line">     writer.writeUtf8(VERSION_1).writeByte(<span class="string">'\n'</span>);</span><br><span class="line">     writer.writeDecimalLong(appVersion).writeByte(<span class="string">'\n'</span>);</span><br><span class="line">     writer.writeDecimalLong(valueCount).writeByte(<span class="string">'\n'</span>);</span><br><span class="line">     writer.writeByte(<span class="string">'\n'</span>);</span><br><span class="line"><span class="comment">//利用刚才逐行读的内容按照格式重新构建</span></span><br><span class="line">     <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         writer.writeUtf8(DIRTY).writeByte(<span class="string">' '</span>);</span><br><span class="line">         writer.writeUtf8(entry.key);</span><br><span class="line">         writer.writeByte(<span class="string">'\n'</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         writer.writeUtf8(CLEAN).writeByte(<span class="string">' '</span>);</span><br><span class="line">         writer.writeUtf8(entry.key);</span><br><span class="line">         entry.writeLengths(writer);</span><br><span class="line">         writer.writeByte(<span class="string">'\n'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     writer.close();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//用新构建的journalFileTmp替换当前的journalFile文件</span></span><br><span class="line">   <span class="keyword">if</span> (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">     fileSystem.rename(journalFile, journalFileBackup);</span><br><span class="line">   &#125;</span><br><span class="line">   fileSystem.rename(journalFileTmp, journalFile);</span><br><span class="line">   fileSystem.delete(journalFileBackup);</span><br><span class="line"></span><br><span class="line">   journalWriter = newJournalWriter();</span><br><span class="line">   hasJournalErrors = <span class="keyword">false</span>;</span><br><span class="line">   mostRecentRebuildFailed = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>到这里<code>readJournal()</code>方法分析完了，总结这个方法的作用：<strong>主要是读取<code>journalFile</code>，根据日志文件中的日志信息，过滤无用冗余的信息，有冗余的则重新构建，最后保证<code>journalFile</code>文件中没有冗余信息</strong>。</p>
<p>执行完<code>readJournal()</code>，回到<code>initialize()</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prefer to pick up where we left off.</span></span><br><span class="line">    <span class="keyword">if</span> (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        readJournal();</span><br><span class="line">        processJournal();</span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">        Platform.get().log(WARN, <span class="string">"DiskLruCache "</span> + directory + <span class="string">" is corrupt: "</span></span><br><span class="line">            + journalIsCorrupt.getMessage() + <span class="string">", removing"</span>, journalIsCorrupt);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span></span><br><span class="line">      <span class="comment">// we'll let that propagate out as it likely means there is a severe filesystem problem.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        delete();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closed = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>readJournal()</code>-&gt;<code>processJournal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries</span></span><br><span class="line"><span class="comment"> * are assumed to be inconsistent and will be deleted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  fileSystem.delete(journalFileTmp);<span class="comment">//删除journalFileTmp文件</span></span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Entry entry = i.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor == <span class="keyword">null</span>) &#123;<span class="comment">//表明数据是	CLEAN，循环记录 size</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        size += entry.lengths[t];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//表明数据时DIRTY，删除</span></span><br><span class="line">      entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        fileSystem.delete(entry.cleanFiles[t]);</span><br><span class="line">        fileSystem.delete(entry.dirtyFiles[t]);</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里删除了刚才创建的<code>journalFileTmp</code>文件，并且遍历<code>lruEntries</code>，记录不可编辑的数据长度（也就是CLEAN），删除 DIRTY 数据。也就是只保留 CLEAN 持久性数据，删除编辑的数据。</p>
<p>走完<code>processJournal()</code>方法，接下来就将<code>initialized</code>标记为<code>true</code>，表示初始化完成。到这里其实初始化已经完成了，继续看<code>initialized()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">// The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span><br><span class="line">     // we&apos;ll let that propagate out as it likely means there is a severe filesystem problem.</span><br><span class="line">     try &#123;</span><br><span class="line">       delete();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       closed = false;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   rebuildJournal();</span><br><span class="line"></span><br><span class="line">   initialized = true;</span><br></pre></td></tr></table></figure>
<p>后面就比较简单了，当没有<code>journalFile</code>，则会调用我们刚才分析的方法<code>rebuildJournal()</code>重新创建一个日志文件，仍然将<code>initialized</code>标记为<code>true</code>,只执行一遍。到这里<code>initialized()</code>走完。总结一下这个方法：</p>
<ul>
<li>这个方法线程安全</li>
<li>如果初始化过了，则什么都不干，只初始化一遍</li>
<li>如果有<code>journalFile</code>日志文件。则对<code>journalFile</code>文件和<code>lruEntries</code>进行初始化操作，主要是删除冗余信息，和 DIRTY 信息</li>
<li>没有则构建一个<code>journalFile</code>文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't exist is not currently</span></span><br><span class="line"><span class="comment">   * readable. If a value is returned, it is moved to the head of the LRU queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line"></span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span> || !entry.readable) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Snapshot snapshot = entry.snapshot();</span><br><span class="line">    <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.writeUtf8(READ).writeByte(<span class="string">' '</span>).writeUtf8(key).writeByte(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">      executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> snapshot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这<code>initialized()</code>总算分析完，接下来回到<code>get()</code>。总结下<code>get()</code>方法的主要操作：</p>
<ul>
<li>初始化日志文件和<code>lruEntries</code></li>
<li>检查保证 key 正确后获取缓存中保存的 Entry</li>
<li>操作计数器 +1</li>
<li>往日志文件中写入这次的 READ 操作</li>
<li>根据<code>redundantOpCount</code>判断是否需要清理日志信息</li>
<li>需要则开启线程清理</li>
<li>不需要则返回缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * We only rebuild the journal when it will halve the size of the journal and eliminate at least</span><br><span class="line"> * 2000 ops.</span><br><span class="line"> */</span><br><span class="line">boolean journalRebuildRequired() &#123;</span><br><span class="line">  final int redundantOpCompactThreshold = 2000;</span><br><span class="line">  return redundantOpCount &gt;= redundantOpCompactThreshold</span><br><span class="line">      &amp;&amp; redundantOpCount &gt;= lruEntries.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到清理的条件是当前<code>redundantOpCount</code>大于2000，并且<code>redundantOpCount</code>的值大于<code>linkedList</code>里面的size。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!initialized | closed) &#123;<span class="comment">//如果没有初始化或者已经关闭了，则不需要清理，这里注意|和||的区别，|会两个条件都检查</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Nothing to do</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        trimToSize();<span class="comment">//清理</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        mostRecentTrimFailed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (journalRebuildRequired()) &#123;<span class="comment">//如果还要清理。重新构建</span></span><br><span class="line">          rebuildJournal();</span><br><span class="line">          redundantOpCount = <span class="number">0</span>;<span class="comment">//计数器置0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        mostRecentRebuildFailed = <span class="keyword">true</span>;<span class="comment">//如果抛异常了，设置最近的一次构建失败</span></span><br><span class="line">        journalWriter = Okio.buffer(Okio.blackhole());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里先总结一下这一块清理的操作流程：</p>
<ol>
<li>如果还没有初始化或者缓存关闭了，则不清理</li>
<li>执行清理操作</li>
<li>如果清理完了还是判断后还是需要清理，只能重新构建日志文件，并且日志记录器记0。</li>
</ol>
<p>这里主要就需要看一下清理操作<code>trimToSize()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (size &gt; maxSize) &#123;</span><br><span class="line">    Entry toEvict = lruEntries.values().iterator().next();</span><br><span class="line">    removeEntry(toEvict);</span><br><span class="line">  &#125;</span><br><span class="line">  mostRecentTrimFailed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeEntry</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//结束editor</span></span><br><span class="line">    entry.currentEditor.detach(); <span class="comment">// Prevent the edit from completing normally.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      <span class="comment">//清除用于保存文件的cleanFiles</span></span><br><span class="line">    fileSystem.delete(entry.cleanFiles[i]);</span><br><span class="line">    size -= entry.lengths[i];</span><br><span class="line">    entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;<span class="comment">//计数器加1</span></span><br><span class="line">  journalWriter.writeUtf8(REMOVE).writeByte(<span class="string">' '</span>).writeUtf8(entry.key).writeByte(<span class="string">'\n'</span>);<span class="comment">//增加一条删除日志</span></span><br><span class="line">  lruEntries.remove(entry.key);<span class="comment">//移除Entry</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;<span class="comment">//如果需要重新清理一下，边界情况</span></span><br><span class="line">    executor.execute(cleanupRunnable);<span class="comment">//清理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的执行流程：</p>
<ol>
<li>停止编辑操作</li>
<li>清除用于保存的<code>cleanFiles</code>‘</li>
<li>增加一条清除日志记录，计数器+1</li>
<li>移除对应 key 的 Entry</li>
<li>由于增加了一条日志，判断是否需要清理，不然可能会越清越多</li>
</ol>
<p>至此，<code>DiskLruCache</code>的<code>get()</code>方法终于分析完成，接着就要返回<code>Cache</code>中的<code>get()</code>方法继续看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">  String key = key(request.url());</span><br><span class="line">  DiskLruCache.Snapshot snapshot;</span><br><span class="line">  Entry entry;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    snapshot = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没拿到，返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// Give up because the cache cannot be read.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建一个Entry，这里传入的是CleanFiles数组中的第一个（ENTRY_METADATA = 0），得到是头信息，也就是key.0</span></span><br><span class="line">    entry = <span class="keyword">new</span> Entry(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Util.closeQuietly(snapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response = entry.response(snapshot);<span class="comment">//得到缓存构建得到的response</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!entry.matches(request, response)) &#123;</span><br><span class="line">    Util.closeQuietly(response.body());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里通过得到的<code>snapshot.getSource()</code>构建了<code>Entry</code>（这个<code>Entry</code>是<code>Cache</code>的内部类，不是<code>DiskLruCache</code>的内部类）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Source[] sources;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line">    Snapshot(String key, <span class="keyword">long</span> sequenceNumber, Source[] sources, <span class="keyword">long</span>[] lengths) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.sequenceNumber = sequenceNumber;</span><br><span class="line">      <span class="keyword">this</span>.sources = sources;</span><br><span class="line">      <span class="keyword">this</span>.lengths = lengths;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Source <span class="title">getSource</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sources[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里的<code>getSource()</code>其实就是返回<code>Source</code>数组中的元素，而<code>Source</code>数组是在<code>Snapshot</code>的构造函数的时候赋值的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Snapshot <span class="title">snapshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!Thread.holdsLock(DiskLruCache.<span class="keyword">this</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">  Source[] sources = <span class="keyword">new</span> Source[valueCount];</span><br><span class="line">  <span class="keyword">long</span>[] lengths = <span class="keyword">this</span>.lengths.clone(); <span class="comment">// Defensive copy since these can be zeroed out.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">        <span class="comment">//可以看到这里其实就是将cleanFiles传给了sources</span></span><br><span class="line">      sources[i] = fileSystem.source(cleanFiles[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(key, sequenceNumber, sources, lengths);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// A file must have been deleted manually!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sources[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Util.closeQuietly(sources[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache</span></span><br><span class="line">    <span class="comment">// size.)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      removeEntry(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个方法，其实应该注意到这个就是我们在调用<code>DiskLruCache</code>中的<code>get()</code>时最后返回的<code>Snapshot</code>调用的方法，具体下方代码贴出了，这时候可以看到<code>source</code>数组其实是将<code>entry</code>中的<code>cleanFile</code>数组对应的保存到<code>source</code>数组中，<strong>这也验证了我们前面说的 clean 数组是用来保存持久性数据，也就是真正用来存东西的地方</strong>，而且前面提到<code>ENTRY_METADATA = 0</code>，所以对应的取的也是 clean 数组中的第一个文件，<strong>也验证了前面说的 clean 数组分两部分，第一部分保存头，第二部分保存 body</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Snapshot snapshot = entry.snapshot();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来看一下<code>Cache</code>中<code>Entry</code>这个内部类，<strong>注意不是 DiskLruCache</strong> 中的 Entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(Source in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    BufferedSource source = Okio.buffer(in);</span><br><span class="line">    url = source.readUtf8LineStrict();</span><br><span class="line">    requestMethod = source.readUtf8LineStrict();</span><br><span class="line">      <span class="comment">//得到cleanfiles[0]来构建头信息</span></span><br><span class="line">    Headers.Builder varyHeadersBuilder = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">    <span class="keyword">int</span> varyRequestHeaderLineCount = readInt(source);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; varyRequestHeaderLineCount; i++) &#123;</span><br><span class="line">      varyHeadersBuilder.addLenient(source.readUtf8LineStrict());</span><br><span class="line">    &#125;</span><br><span class="line">    varyHeaders = varyHeadersBuilder.build();</span><br><span class="line"></span><br><span class="line">    StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());</span><br><span class="line">    protocol = statusLine.protocol;</span><br><span class="line">    code = statusLine.code;</span><br><span class="line">    message = statusLine.message;</span><br><span class="line">    Headers.Builder responseHeadersBuilder = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">    <span class="keyword">int</span> responseHeaderLineCount = readInt(source);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaderLineCount; i++) &#123;</span><br><span class="line">      responseHeadersBuilder.addLenient(source.readUtf8LineStrict());</span><br><span class="line">    &#125;</span><br><span class="line">    String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);</span><br><span class="line">    String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);</span><br><span class="line">    responseHeadersBuilder.removeAll(SENT_MILLIS);</span><br><span class="line">    responseHeadersBuilder.removeAll(RECEIVED_MILLIS);</span><br><span class="line">    sentRequestMillis = sendRequestMillisString != <span class="keyword">null</span></span><br><span class="line">        ? Long.parseLong(sendRequestMillisString)</span><br><span class="line">        : <span class="number">0L</span>;</span><br><span class="line">    receivedResponseMillis = receivedResponseMillisString != <span class="keyword">null</span></span><br><span class="line">        ? Long.parseLong(receivedResponseMillisString)</span><br><span class="line">        : <span class="number">0L</span>;</span><br><span class="line">    responseHeaders = responseHeadersBuilder.build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isHttps()) &#123;</span><br><span class="line">      String blank = source.readUtf8LineStrict();</span><br><span class="line">      <span class="keyword">if</span> (blank.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"expected \"\" but was \""</span> + blank + <span class="string">"\""</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      String cipherSuiteString = source.readUtf8LineStrict();</span><br><span class="line">      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);</span><br><span class="line">      List&lt;Certificate&gt; peerCertificates = readCertificateList(source);</span><br><span class="line">      List&lt;Certificate&gt; localCertificates = readCertificateList(source);</span><br><span class="line">      TlsVersion tlsVersion = !source.exhausted()</span><br><span class="line">          ? TlsVersion.forJavaName(source.readUtf8LineStrict())</span><br><span class="line">          : <span class="keyword">null</span>;</span><br><span class="line">      handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handshake = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过 Entry 的构造方法更能说明 clean 数组中的第一项是用来保存 header 信息的，从代码中科院看到利用<code>Header.builder</code>对传入进来的<code>Source</code>（也就是<code>clean[0]</code>）进行构建，最后利用<code>build()</code>方法构建了 header 信息。</p>
<p>头构建完了，现在就需要找构建 body 的地方，因为剩下的代码只剩下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response response = entry.response(snapshot);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Response response(DiskLruCache.Snapshot snapshot) &#123;</span><br><span class="line">  String contentType = responseHeaders.get(&quot;Content-Type&quot;);</span><br><span class="line">  String contentLength = responseHeaders.get(&quot;Content-Length&quot;);</span><br><span class="line">  Request cacheRequest = new Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .method(requestMethod, null)</span><br><span class="line">      .headers(varyHeaders)</span><br><span class="line">      .build();</span><br><span class="line">  return new Response.Builder()</span><br><span class="line">      .request(cacheRequest)</span><br><span class="line">      .protocol(protocol)</span><br><span class="line">      .code(code)</span><br><span class="line">      .message(message)</span><br><span class="line">      .headers(responseHeaders)</span><br><span class="line">      .body(new CacheResponseBody(snapshot, contentType, contentLength))</span><br><span class="line">      .handshake(handshake)</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(receivedResponseMillis)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法的作用基本上就是利用<code>Response.builder</code>构建缓存中的<code>Response</code>了，但是没有找到明显的写入<code>Body</code>的地方，唯一有 body 的就是<code>.body(new CacheResponseBody(snapshot, contentType, contentLength))</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheResponseBody</span><span class="params">(<span class="keyword">final</span> DiskLruCache.Snapshot snapshot,</span></span></span><br><span class="line"><span class="function"><span class="params">        String contentType, String contentLength)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.snapshot = snapshot;</span><br><span class="line">      <span class="keyword">this</span>.contentType = contentType;</span><br><span class="line">      <span class="keyword">this</span>.contentLength = contentLength;</span><br><span class="line">	<span class="comment">//这里的 ENTRY_BODY = 1，同样拿的是 CleanFils 数组，构建 ResponseBody</span></span><br><span class="line">      Source source = snapshot.getSource(ENTRY_BODY);</span><br><span class="line">      bodySource = Okio.buffer(<span class="keyword">new</span> ForwardingSource(source) &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          snapshot.close();</span><br><span class="line">          <span class="keyword">super</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到现在可以看出来，<strong>clean 数组的 0 对应保存 Header 信息，1 对应保存 Body 信息</strong>。</p>
<p>这里分析完构建 header 和 body 得到对应的缓存的 Response 后，对应的从缓存中拿缓存的 Response 流程终于结束了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//默认cache为null,可以配置cache,不为空尝试获取缓存中的response</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//根据response,time,request创建一个缓存策略，用于判断怎样使用缓存</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">//如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(<span class="number">504</span>)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">//不使用网络，但是又缓存，直接返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//直接走后续过滤器</span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="comment">//当缓存响应和网络响应同时存在的时候，选择用哪个</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="comment">//如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户</span></span><br><span class="line">        <span class="comment">// 只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</span></span><br><span class="line">        <span class="comment">//则使用缓存的响应</span></span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用网络响应</span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//所以默认创建的OkHttpClient是没有缓存的</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//将响应缓存</span></span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="comment">//缓存Resposne的Header信息</span></span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        <span class="comment">//缓存body</span></span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//只能缓存GET....不然移除request</span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以分析<code>CacheInterceptor</code>主要流程</p>
<ol>
<li>通过 Request 尝试到 Cache 中拿缓存（里面非常多流程），当然前提是<code>OkHttpClient</code>中配置了缓存，默认是不支持的</li>
<li>根据 response，time，request 创建一个缓存策略，用于判断怎样使用缓存</li>
<li>如果缓存策略中设置禁止使用网络，并且缓存又为空，则构建一个 Response 直接返回，注意返回码 = 504</li>
<li>缓存策略中设置不使用网络，但是有缓存，直接返回缓存</li>
<li>接着走后续过滤器的流程：<code>chain.proceed(networkRequest)</code></li>
<li>当缓存存在的时候，如果网络返回的 Response 为 304，则使用缓存的 Response</li>
<li>构建网络请求的 Response</li>
<li>挡在 OkHttpClient 中配置了缓存，则将这个 Response 缓存起来</li>
<li>缓存起来的步骤也是先缓存 header，再缓存 body</li>
<li>返回 Response</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//将响应缓存</span></span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="comment">//缓存Resposne的Header信息</span></span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        <span class="comment">//缓存body</span></span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//只能缓存GET....不然移除request</span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当可以缓存的时候，这里用了<code>cache.put(response)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">  String requestMethod = response.request().method();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request().method())) &#123;</span><br><span class="line">      <span class="comment">//Okhttp只能缓存 GET 请求！</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      remove(response.request());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">      <span class="comment">// The cache cannot be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!requestMethod.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">      <span class="comment">//Okhttp只能缓存 GET 请求！</span></span><br><span class="line">    <span class="comment">// Don't cache non-GET responses. We're technically allowed to cache</span></span><br><span class="line">    <span class="comment">// HEAD requests and some POST requests, but the complexity of doing</span></span><br><span class="line">    <span class="comment">// so is high and the benefit is low.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpHeaders.hasVaryAll(response)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Entry entry = <span class="keyword">new</span> Entry(response);</span><br><span class="line">  DiskLruCache.Editor editor = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    editor = cache.edit(key(response.request().url()));</span><br><span class="line">    <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    entry.writeTo(editor);<span class="comment">//缓存了Header信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    abortQuietly(editor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从效率角度考虑，OkHttp 暂时只支持 GET 形式的缓存。（如果需要支持，对应的其实也就是修改源码，将这里的判断给删除）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//缓存了Header信息</span><br><span class="line">      entry.writeTo(editor);</span><br><span class="line">//Entry的writeTo方法===============================</span><br><span class="line">public void writeTo(DiskLruCache.Editor editor) throws IOException &#123;</span><br><span class="line">      //往dirty中写入header信息，ENTRY_METADATA=0，所以是dirtyFiles[0]</span><br><span class="line">      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));</span><br><span class="line"></span><br><span class="line">      sink.writeUtf8(url)</span><br><span class="line">          .writeByte(&apos;\n&apos;);</span><br><span class="line">      sink.writeUtf8(requestMethod)</span><br><span class="line">          .writeByte(&apos;\n&apos;);</span><br><span class="line">      sink.writeDecimalLong(varyHeaders.size())</span><br><span class="line">          .writeByte(&apos;\n&apos;);</span><br><span class="line">      for (int i = 0, size = varyHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">            .writeUtf8(&quot;: &quot;)</span><br><span class="line">            .writeUtf8(varyHeaders.value(i))</span><br><span class="line">            .writeByte(&apos;\n&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      sink.writeUtf8(new StatusLine(protocol, code, message).toString())</span><br><span class="line">          .writeByte(&apos;\n&apos;);</span><br><span class="line">      sink.writeDecimalLong(responseHeaders.size() + 2)</span><br><span class="line">          .writeByte(&apos;\n&apos;);</span><br><span class="line">      for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        sink.writeUtf8(responseHeaders.name(i))</span><br><span class="line">            .writeUtf8(&quot;: &quot;)</span><br><span class="line">            .writeUtf8(responseHeaders.value(i))</span><br><span class="line">            .writeByte(&apos;\n&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">      sink.writeUtf8(SENT_MILLIS)</span><br><span class="line">          .writeUtf8(&quot;: &quot;)</span><br><span class="line">          .writeDecimalLong(sentRequestMillis)</span><br><span class="line">          .writeByte(&apos;\n&apos;);</span><br><span class="line">      sink.writeUtf8(RECEIVED_MILLIS)</span><br><span class="line">          .writeUtf8(&quot;: &quot;)</span><br><span class="line">          .writeDecimalLong(receivedResponseMillis)</span><br><span class="line">          .writeByte(&apos;\n&apos;);</span><br><span class="line"></span><br><span class="line">      if (isHttps()) &#123;</span><br><span class="line">        sink.writeByte(&apos;\n&apos;);</span><br><span class="line">        sink.writeUtf8(handshake.cipherSuite().javaName())</span><br><span class="line">            .writeByte(&apos;\n&apos;);</span><br><span class="line">        writeCertList(sink, handshake.peerCertificates());</span><br><span class="line">        writeCertList(sink, handshake.localCertificates());</span><br><span class="line">        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte(&apos;\n&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">      sink.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里对应的其实就是往<code>dirtyFiles[0]</code>中写入 header 信息，而待会对应的 1 就是 写入 body 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存了Header信息</span></span><br><span class="line">  entry.writeTo(editor);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</span><br></pre></td></tr></table></figure>
<p>写完header后，继续找写body的地方，这里返回了一个CacheRequestImpl对象，一定不要忽略，不然就找不到写body的地方了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheRequestImpl</span><span class="params">(<span class="keyword">final</span> DiskLruCache.Editor editor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.editor = editor;</span><br><span class="line">  <span class="keyword">this</span>.cacheOut = editor.newSink(ENTRY_BODY);<span class="comment">//ENTRY_BODY = 1</span></span><br><span class="line">  <span class="keyword">this</span>.body = <span class="keyword">new</span> ForwardingSink(cacheOut) &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Cache.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        writeSuccessCount++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">super</span>.close();</span><br><span class="line">      editor.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到ENTRY_BODY就放心， 这里对应的ENTRY_BODY=1对应的就是数组的第二个位置。那到了数据源，接着就要找写入的地方，这里还要注意一个地方<strong><code>editor.commit();</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheIntercetor中==========================</span></span><br><span class="line">      <span class="comment">//缓存Resposne的Header信息</span></span><br><span class="line">      CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">      <span class="comment">//缓存body</span></span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">cacheWritingResponse</span><span class="params">(<span class="keyword">final</span> CacheRequest cacheRequest, Response response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Some apps return a null body; for compatibility we treat that like a null cache request.</span></span><br><span class="line">    <span class="keyword">if</span> (cacheRequest == <span class="keyword">null</span>) <span class="keyword">return</span> response;</span><br><span class="line">    Sink cacheBodyUnbuffered = cacheRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (cacheBodyUnbuffered == <span class="keyword">null</span>) <span class="keyword">return</span> response;</span><br><span class="line">    <span class="comment">//获得body</span></span><br><span class="line">    <span class="keyword">final</span> BufferedSource source = response.body().source();</span><br><span class="line">    <span class="keyword">final</span> BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);</span><br><span class="line"></span><br><span class="line">    Source cacheWritingSource = <span class="keyword">new</span> Source() &#123;</span><br><span class="line">      <span class="keyword">boolean</span> cacheRequestClosed;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> bytesRead;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          bytesRead = source.read(sink, byteCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">            cacheRequestClosed = <span class="keyword">true</span>;</span><br><span class="line">            cacheRequest.abort(); <span class="comment">// Failed to write a complete cache response.</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">            cacheRequestClosed = <span class="keyword">true</span>;</span><br><span class="line">            cacheBody.close(); <span class="comment">// The cache response is complete!</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读的时候会将body写入</span></span><br><span class="line">        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);</span><br><span class="line">        cacheBody.emitCompleteSegments();</span><br><span class="line">        <span class="keyword">return</span> bytesRead;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Timeout <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source.timeout();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheRequestClosed</span><br><span class="line">            &amp;&amp; !discard(<span class="keyword">this</span>, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">          cacheRequestClosed = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//关闭的时候会执行commit操作，最终合并header和body，完成缓存</span></span><br><span class="line">          cacheRequest.abort();</span><br><span class="line">        &#125;</span><br><span class="line">        source.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String contentType = response.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">    <span class="keyword">long</span> contentLength = response.body().contentLength();</span><br><span class="line">    <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">        .body(<span class="keyword">new</span> RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3 .总结"></a>3 .总结</h4><ol>
<li>缓存中是有日志文件用于保存操作纪律</li>
<li>缓存中的 Entry 有用 CleanFIles 和 DirtyFiles，其中 Clean 是用于保存持久性数据的，也就是真正保存数据的地方；Dirty 是用于保存编辑过程中的数据的</li>
<li>两个数组大小都为2，第一个保存 Header 信息，第二个保存 Body 信息。</li>
</ol>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><hr>
<h2 id="参考引用其实就是照着打这样我会比较专注"><a href="#参考引用其实就是照着打这样我会比较专注" class="headerlink" title="参考引用其实就是照着打这样我会比较专注"></a>参考引用其实就是照着打这样我会比较专注</h2><p><a href="https://www.jianshu.com/p/37e26f4ea57b" target="_blank" rel="noopener">okhttp源码分析（一）——基本流程（超详细）</a></p>

  </div>
</article>

	<div class="blog-post-comments">
        
        
        <div class="vcomment"></div>
        
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单使用"><span class="toc-number">1.</span> <span class="toc-text">简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Http-Get"><span class="toc-number">1.1.</span> <span class="toc-text">Http Get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http-Post-携带参数"><span class="toc-number">1.2.</span> <span class="toc-text">Http Post 携带参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于-Http-的文件上传"><span class="toc-number">1.3.</span> <span class="toc-text">基于 Http 的文件上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-number">1.4.</span> <span class="toc-text">封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本流程"><span class="toc-number">2.1.</span> <span class="toc-text">基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-OkHttpClient"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.OkHttpClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Request"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.Request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-异步请求"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.异步请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-同步请求"><span class="toc-number">2.1.4.</span> <span class="toc-text">4.同步请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RetryAndFollowUpInterceptor"><span class="toc-number">2.2.</span> <span class="toc-text">RetryAndFollowUpInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-宏观流程"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.宏观流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-过程细节"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.过程细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-总结"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheInterceptor"><span class="toc-number">2.3.</span> <span class="toc-text">CacheInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-宏观流程-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.宏观流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-过程细节-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.过程细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-总结-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">3 .总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConnectInterceptor"><span class="toc-number">2.4.</span> <span class="toc-text">ConnectInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CallServerInterceptor"><span class="toc-number">2.5.</span> <span class="toc-text">CallServerInterceptor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考引用其实就是照着打这样我会比较专注"><span class="toc-number">3.</span> <span class="toc-text">参考引用其实就是照着打这样我会比较专注</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/04/06/关于-okhttp/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/04/06/关于-okhttp/&text=关于 okhttp"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/04/06/关于-okhttp/&is_video=false&description=关于 okhttp"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于 okhttp&body=Check out this article: http://yoursite.com/2019/04/06/关于-okhttp/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/04/06/关于-okhttp/&title=关于 okhttp"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/04/06/关于-okhttp/&name=关于 okhttp&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 黄耿
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

<!-- Valine Comments -->

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<script type="text/javascript">
    var notify = 'false' == true ? true : false;
    var verify = 'false' == true ? true : false;
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
      return GUEST_INFO.indexOf(item) > -1
    });
    guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "QkzLlK1k0KOnWTQtGcA7pnfP-gzGzoHsz",
        appKey: "3x2y811wfs2AtVQEz7kKeMhL",
        avatar:"mm",
        placeholder: "say somethings ?",
        guest_info:guest_info,
        pageSize:"10"
    })
</script>
 
</body>
</html>
