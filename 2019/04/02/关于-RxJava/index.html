<!DOCTYPE html>
<html lang=en>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="RxJava 笔记RxJava 其实就是一个实现异步操作的库，由表示数据源的一组类、用于监听数据源的一组类，用于修改与合并数据的一组方法组成，使用的就是通用形式的观察者模式。RxJava 优势在于能把复杂逻辑简洁化。  RxJava 的观察者模式 RxJava 有四个基本概念：  Observable（可观察者，即被观察者） Observer （观察者） subscribe（订阅） 事件  与传统">
<meta name="keywords" content="Android 面试">
<meta property="og:type" content="article">
<meta property="og:title" content="关于 RxJava">
<meta property="og:url" content="http://yoursite.com/2019/04/02/关于-RxJava/index.html">
<meta property="og:site_name" content="Okkenok">
<meta property="og:description" content="RxJava 笔记RxJava 其实就是一个实现异步操作的库，由表示数据源的一组类、用于监听数据源的一组类，用于修改与合并数据的一组方法组成，使用的就是通用形式的观察者模式。RxJava 优势在于能把复杂逻辑简洁化。  RxJava 的观察者模式 RxJava 有四个基本概念：  Observable（可观察者，即被观察者） Observer （观察者） subscribe（订阅） 事件  与传统">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcrna27j20h40d1q4f.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcvophmj20h30hl0v3.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxcynbsuj20ha0d7wg2.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxd05lttj20hj0cyabl.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxd1vl7xj20hd0hzq6e.jpg">
<meta property="og:image" content="http://www.10tiao.com/img.do?url=https%3A//mmbiz.qpic.cn/mmbiz_png/v1LbPPWiaSt7pQP1OY2Z5Yibfc3R812PxPpp6gUiaSaYnkFUtz5NZA5xub84R57u0ialiczibY1Kwetia2HfowO5bp0ag/640%3Fwx_fmt%3Dpng">
<meta property="og:updated_time" content="2019-04-02T14:14:28.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于 RxJava">
<meta name="twitter:description" content="RxJava 笔记RxJava 其实就是一个实现异步操作的库，由表示数据源的一组类、用于监听数据源的一组类，用于修改与合并数据的一组方法组成，使用的就是通用形式的观察者模式。RxJava 优势在于能把复杂逻辑简洁化。  RxJava 的观察者模式 RxJava 有四个基本概念：  Observable（可观察者，即被观察者） Observer （观察者） subscribe（订阅） 事件  与传统">
<meta name="twitter:image" content="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>关于 RxJava</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/03/31/MVC-MVP-MVVM/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/04/02/关于-RxJava/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/04/02/关于-RxJava/&text=关于 RxJava"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/04/02/关于-RxJava/&is_video=false&description=关于 RxJava"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于 RxJava&body=Check out this article: http://yoursite.com/2019/04/02/关于-RxJava/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/04/02/关于-RxJava/&name=关于 RxJava&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RxJava-笔记"><span class="toc-number">1.</span> <span class="toc-text">RxJava 笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RxJava-的观察者模式"><span class="toc-number">1.1.</span> <span class="toc-text">RxJava 的观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本实现"><span class="toc-number">1.2.</span> <span class="toc-text">基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Observer"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建 Observer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Observable"><span class="toc-number">1.2.2.</span> <span class="toc-text">创建 Observable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subscribe（订阅）"><span class="toc-number">1.2.3.</span> <span class="toc-text">Subscribe（订阅）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程控制——-Scheduler"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程控制—— Scheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scheduler-的-API"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Scheduler 的 API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变换"><span class="toc-number">1.2.5.</span> <span class="toc-text">变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变换的原理：lift"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">变换的原理：lift()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compose-：对-Observable-整体的变换"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">compose()：对 Observable 整体的变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程控制-PLUS"><span class="toc-number">1.2.6.</span> <span class="toc-text">线程控制 PLUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduler-的原理"><span class="toc-number">1.2.7.</span> <span class="toc-text">Scheduler 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doOnSubscribe"><span class="toc-number">1.2.8.</span> <span class="toc-text">doOnSubscribe()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Observable-create-oos"><span class="toc-number">2.1.</span> <span class="toc-text">Observable.create(oos)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#observeOn-AndroidSchedulers-mainThread"><span class="toc-number">2.2.</span> <span class="toc-text">observeOn(AndroidSchedulers.mainThread())</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subscribeOn-Schedulers-computation"><span class="toc-number">2.3.</span> <span class="toc-text">subscribeOn(Schedulers.computation())</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subscribe-o"><span class="toc-number">2.4.</span> <span class="toc-text">subscribe(o)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程切换"><span class="toc-number">2.5.</span> <span class="toc-text">线程切换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        关于 RxJava
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Okkenok</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-04-02T14:13:43.000Z" itemprop="datePublished">2019-04-02</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Android-面试/">Android 面试</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="RxJava-笔记"><a href="#RxJava-笔记" class="headerlink" title="RxJava 笔记"></a>RxJava 笔记</h1><p>RxJava 其实就是一个实现<strong>异步操作</strong>的库，由表示数据源的一组类、用于监听数据源的一组类，用于修改与合并数据的一组方法组成，使用的就是通用形式的<strong>观察者模式</strong>。RxJava 优势在于能把复杂逻辑简洁化。 </p>
<h2 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h2><p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg" alt="jpg"></p>
<p>RxJava 有四个基本概念：</p>
<ul>
<li>Observable（可观察者，即被观察者）</li>
<li>Observer （观察者）</li>
<li>subscribe（订阅）</li>
<li>事件</li>
</ul>
<p>与传统的观察者模式不同，RxJava 的事件回调方法除了普通事件<code>onNext()</code>(相当于<code>onClick()</code>/<code>onEvent()</code>)之外，还定义了两个特殊的事件回调<code>onCompleted()</code>和<code>onError()</code>。</p>
<ul>
<li><code>onCompleted()</code>：事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会有新的<code>onNext()</code>发出时，需触发<code>onCompleted()</code>作为标志。</li>
<li><code>onError()</code>：事件队列异常。在事件处理过程中出现异常时，<code>onError()</code>会被触发，同时队列会自动终止，不允许再有事件发出。</li>
</ul>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><h3 id="创建-Observer"><a href="#创建-Observer" class="headerlink" title="创建 Observer"></a>创建 Observer</h3><p>Observer 决定事件触发的时候将有怎样的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = new Observer&lt;String&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Overrider </span><br><span class="line">    public void onCompleted()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onError()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<code>Observer</code>接口之外，RxJava 还内置了一个实现了<code>Observer</code>的抽象类：<code>Subscriber</code>。<code>Subscriber</code>对<code>Observer</code>接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，<code>Observer</code>也总是先被转换成一个<code>Subscriber</code>再使用。所以如果只是使用基本功能，选择<code>Observer</code>和<code>Subscriber</code>是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<ol>
<li><code>onStart()</code>：在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行），<code>onStart()</code>就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要指定的线程来做准备工作，可以使用<code>doOnSubscribe()</code>。</li>
<li><code>unsubscribe()</code>：这是<code>Subscriber</code>所实现的另一个接口<code>Subscription</code>的方法，用于取消订阅。在这个方法被调用后，<code>Subscriber</code>将不再接收事件。一般在这个方法调用前，可以使用<code>isUnsubscribed()</code>先判断下状态。<strong><code>unsubscribe()</code>这个方法很重要，因为在<code>subscribe()</code>之后，<code>Observable</code>会持有<code>Subscriber</code>的引用，这个引用如若不能及时被释放，将有内存泄漏的风险。</strong>所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（<code>onPause()</code>、<code>onStop()</code>等方法中）调用<code>unsubscribe()</code>来解除引用关系，以避免内存泄漏的发生。</li>
</ol>
<h3 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 Observable</h3><p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSunscribe&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span></span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当<code>Observable</code>被订阅的时候，<code>OnSubscribe</code>的<code>call()</code>方法会自动被调用，事件序列就会依照设定依次触发。<code>create()</code>方法是 RxJava 最基本创造事件序列的方法。还有一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obervable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br></pre></td></tr></table></figure>
<h3 id="Subscribe（订阅）"><a href="#Subscribe（订阅）" class="headerlink" title="Subscribe（订阅）"></a>Subscribe（订阅）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br><span class="line"></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p><code>Observable.subscribe(Subscriber)</code>内部实现（仅核心代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span></span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber); <span class="comment">// 事件发送的逻辑开始运行。</span></span><br><span class="line">    <span class="keyword">return</span> subscriber; <span class="comment">// 作为 Subscription 返回，方便 unsubscribe()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上可以看出，<strong><code>Observable</code>并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候才开始发送事件，即当<code>subscribe()</code>方法执行的时候</strong>。</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg" alt="subscribe"></p>
<p>除了<code>subscribe(Observer)</code>和<code>subscribe(Subscriber)</code>，<code>subscribe()</code>还支持不完整定义的回调，RxJava 会自动根据定义创建出<code>Subscriber</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;()&#123;</span><br><span class="line">    <span class="comment">// onNext()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;()&#123;</span><br><span class="line">    <span class="comment">// onError()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0()&#123;</span><br><span class="line">    <span class="comment">// onCompleted()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</span><br></pre></td></tr></table></figure>
<p>简单使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="线程控制——-Scheduler"><a href="#线程控制——-Scheduler" class="headerlink" title="线程控制—— Scheduler"></a>线程控制—— Scheduler</h3><p>在不指定线程的情况下，在哪个线程调用<code>subscribe()</code>，就在哪个线程生产事件，在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到<code>Scheduler</code>（调度器）。</p>
<h4 id="Scheduler-的-API"><a href="#Scheduler-的-API" class="headerlink" title="Scheduler 的 API"></a>Scheduler 的 API</h4><ul>
<li><code>Schedulers.immediate()</code>：默认</li>
<li><code>Schedulers.newThread()</code>：总是启用新线程，并在新线程执行操作</li>
<li><code>Schedulers.io()</code>：I/O 操作（读写文件、读写数据库、网络信息交互等）。行为模式和<code>newThread()</code>差不多，区别在于<code>io()</code>的内部实现是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下<code>io()</code>比<code>newThread()</code>更有效率。不要把计算工作放在<code>io()</code>中，可以避免创建不必要的线程。</li>
<li><code>Schedulers.computation()</code>计算所使用的，这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的计算，例如图形的计算。使用的固定的线程池，大小为 CPU 核数。</li>
<li><code>AndroidSchedulers.mainThread()</code>：指定的操作在Android 主线程运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io()) <span class="comment">//指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">//指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span></span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>RxJava 提供了对事件序列进行变换的支持。所谓变换，<strong>就是将事件队列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列</strong>。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"images/logo.png"</span>)</span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;()&#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        	showBitmap(bitmap);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Func1</code>也是 RxJava 的一个接口。<code>Func1</code>和<code>Action</code>的区别在于，<code>Func1</code>包装的是有返回值的方法。</p>
</blockquote>
<ul>
<li><code>map()</code>：事件对象的直接变换</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg" alt="变换"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span></span>&#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(student.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscriber(subscriber);</span><br></pre></td></tr></table></figure>
<p><code>flatMap()</code>和<code>map()</code>有一个相同点：把传入的参数转化后返回另一对象。<code>flatMap()</code>的原理步骤是：</p>
<ol>
<li>使用传入的事件对象创建一个<code>Observable</code>对象</li>
<li>并不发送这个<code>Observable</code>，而是将它激活，于是它开始发送事件</li>
<li>每一个创建出来的<code>Observable</code>发送的事件，都被汇入同一个<code>Observable</code>，而这个<code>Observable</code>负责将这些事件同一交给<code>Subscriber</code>的回调方法。</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg" alt="flatMap()流程"></p>
<h4 id="变换的原理：lift"><a href="#变换的原理：lift" class="headerlink" title="变换的原理：lift()"></a>变换的原理：<code>lift()</code></h4><p>RxJava 提供了很多便捷的方法来实现事件序列的变换，这些变换虽然功能各有不同，但实质上都是<strong>针对事件序列的处理和再发送</strong>。而在 RxJava 内部，它们是基于同一个基础的变换方法：<code>lift(Operator)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅核心代码</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;R&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span></span>&#123;</span><br><span class="line">            <span class="comment">//Operator通过自己的call()将新的Subscriber和原始的Subscriber进行关联，并插入自己的“变换”代码以实现变换</span></span><br><span class="line">            Subscriber newSubscriber = opertor.call(subscriber);</span><br><span class="line">            newSubscriber.onStart();</span><br><span class="line">            onSubscribe.call(newSubscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Onservable</code>执行了<code>lift(Operator)</code>之后，会返回一个新的<code>Observable</code>，这个新的<code>Observable</code>会像一个代理一样，负责接收原始的<code>Observable</code>发出的事件，并在处理后发送给<code>Subscriber</code>。</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcrna27j20h40d1q4f.jpg" alt="lift() 流程"></p>
<p>两次和多次<code>lift()</code>同理</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcvophmj20h30hl0v3.jpg" alt="两次和多次 lift"></p>
<h4 id="compose-：对-Observable-整体的变换"><a href="#compose-：对-Observable-整体的变换" class="headerlink" title="compose()：对 Observable 整体的变换"></a><code>compose()</code>：对 Observable 整体的变换</h4><p><code>list()</code>是针对事件项和事件序列的，而<code>compose()</code>是针对<code>Observable</code>自身进行变换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observable</span><br><span class="line">            .lift1()</span><br><span class="line">            .lift2()</span><br><span class="line">            .lift3()</span><br><span class="line">            .lift4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</span><br><span class="line">observable1.compose(liftAll).subscribe(subscriber1);</span><br><span class="line">observable2.compose(liftAll).subscribe(subscriber2);</span><br><span class="line">observable3.compose(liftAll).subscribe(subscriber3);</span><br><span class="line">observable4.compose(liftAll).subscribe(subscriber4);</span><br></pre></td></tr></table></figure>
<h3 id="线程控制-PLUS"><a href="#线程控制-PLUS" class="headerlink" title="线程控制 PLUS"></a>线程控制 PLUS</h3><p>能不能多切换几次线程？—— 能！因为<code>observeOn()</code>指定的是<code>Subscriber</code>的线程，而这个<code>Subscriber</code>并不一定是<code>subscribe()</code>参数中的<code>Subscriber</code>，而是<code>observeOn()</code>执行时的当前<code>Observable</code>对应的<code>Subscriber</code>，即它的直接下级<code>Subscriber</code>。换句话说，<code>observeOn()</code>指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次<code>observeOn()</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO线程，由subscribeOn()指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator)<span class="comment">// 新线程，由observeOn()指定</span></span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(maoOperator2)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>不过，不同于<code>observeOn()</code>的多次调用，<code>subscribeOn()</code>位置放在哪里都可以，但它是只能调用一次的。</p>
<h3 id="Scheduler-的原理"><a href="#Scheduler-的原理" class="headerlink" title="Scheduler 的原理"></a>Scheduler 的原理</h3><p><code>subscribeOn()</code>和<code>observeOn()</code>的内部实现，也是用的<code>lift()</code>。</p>
<p><code>subscribeOn()</code>原理图：</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxcynbsuj20ha0d7wg2.jpg" alt="subscribeOn()原理图"></p>
<p><code>observeOn()</code>原理图：</p>
<p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxd05lttj20hj0cyabl.jpg" alt="observeOn()原理图"></p>
<p>从图中可以看出，<code>subscribeOn()</code>和<code>observeOn()</code>都做了线程切换的工作（图中的“schedule…”部位）。不同的是，<strong><code>subscribeOn()</code>的线程切换发生在<code>OnSubscribe</code>中，即在它通知上一级<code>OnSubscribe</code>时，这时时间还没有开始发送</strong>，因此<code>subscribeOn()</code>的线程控制可以从事件发出的开端就造成影响；而<strong><code>observeOn()</code>的线程切换则发生在它内建的<code>Subscriber</code>中，即发生在它即将给下一级<code>Subscriber</code>发送事件时</strong>，因此<code>observeOn()</code>控制的是它后面的线程。</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxd1vl7xj20hd0hzq6e.jpg" alt="多个混合使用"></p>
<p>图中共有 5 处含有对事件的操作。由图中可以看出，① 和 ② 两处受第一个<code>subscribeOn()</code>影响，运行在红色线程；③ 和 ④ 处受第一个<code>observeOn()</code>的影响，运行在绿色线程；⑤ 处受第二个<code>observeOn()</code>影响，运行在紫色线程；而第二个<code>subscribeOn()</code>，由于在通知过程中线程就被第一个<code>subscribeOn()</code>截断，因此对整个流程并没有任何影响。因此，当使用了多个<code>subscribeOn()</code>的时候，只有第一个<code>subscribeOn()</code>起作用。</p>
<h3 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe()"></a>doOnSubscribe()</h3><p>与<code>Subscriber.onStart()</code>同样是在<code>subscribe()</code>调用后而且事件发送之前执行的，但区别是它可以指定线程。默认情况下，<code>doOnSubscribe()</code>执行在<code>subscribe()</code>发生的线程l；<strong>而如果在<code>doOnSubscribe()</code>之后有<code>subscribeOn()</code>的话</strong>，它将执行在离他最近的<code>subscribeOn()</code>所指定的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(onSubscribe)</span><br><span class="line">    .subscrubeOn(Schedulers.io())</span><br><span class="line">    .doOnSubscribe(<span class="keyword">new</span> Action0()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">            progressBar.setVisibility(View.VISIBLE); <span class="comment">//需要在主线程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribeOn(AndroidSchedulers.mainThread()) <span class="comment">//指定主线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainTread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>基于 RxJava 2.1.2</p>
<h2 id="Observable-create-oos"><a href="#Observable-create-oos" class="headerlink" title="Observable.create(oos)"></a><code>Observable.create(oos)</code></h2><p><code>create()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>); <span class="comment">// 简单判空</span></span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create()</code> -&gt; <code>RxJavaPlugins.onAssembly()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Calls the associated hook function.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;T&gt; the value type</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> source the hook's input value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the value returned by the hook</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line">   <span class="meta">@NonNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// onObservableAssembly 是一个静态变量，需要我们主动去设置才会赋值，这里做空来考虑</span></span><br><span class="line">       Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">       <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> apply(f, source);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> source; <span class="comment">//默认什么都没做</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.jianshu.com/p/a0c580ed3432" target="_blank" rel="noopener">钩子函数</a>：函数主动找事件。</p>
</blockquote>
<p>由上知，<code>Observable.craete(oos)</code>只是创建了一个 ObservableCreate 对象。</p>
<h2 id="observeOn-AndroidSchedulers-mainThread"><a href="#observeOn-AndroidSchedulers-mainThread" class="headerlink" title="observeOn(AndroidSchedulers.mainThread())"></a><code>observeOn(AndroidSchedulers.mainThread())</code></h2><p>既然之前的<code>create()</code>方法创建了一个<code>ObservableCreate</code>对象并返回，也就是说<code>observeOn(Schedulers.computation())</code>这个方法调用的是<code>ObservableCreate</code>这个对象的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br></pre></td></tr></table></figure>
<p>没有看到<code>observeOn()</code>，看看父类<code>Observable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">        ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>); <span class="comment">//判别</span></span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又是一个<code>onAssembly()</code>的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//同样的钩子方法</span></span><br><span class="line">        Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> apply(f, source);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的钩子方法，以后只需关心它传递的参数和返回值就行了。故<code>observeOn()</code>就是创建并返回一个<code>ObservableObserveOn</code>对象。</p>
<h2 id="subscribeOn-Schedulers-computation"><a href="#subscribeOn-Schedulers-computation" class="headerlink" title="subscribeOn(Schedulers.computation())"></a><code>subscribeOn(Schedulers.computation())</code></h2><p>由于<code>observeOn()</code>创建并返回了一个<code>ObservableObserveOn</code>对象，所以这里调用的是<code>ObservableObserveOn</code>对象上的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">U</span>&gt; <span class="keyword">implements</span> <span class="title">HasUpstreamObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>
<p>也是继承于<code>Observable</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123; </span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>); </span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但其实，<code>observeOn()</code>和<code>subscribeOn()</code>并没有什么使用顺序，而先前<code>create()</code>得到的<code>Observable</code>对象，我们也可以直接找到。<code>subscribeOn()</code>为 final 方法，创建了一个<code>ObservableSubscribeOn</code>对象并返回。</p>
<h2 id="subscribe-o"><a href="#subscribe-o" class="headerlink" title="subscribe(o)"></a><code>subscribe(o)</code></h2><p><code>Observable</code>中的 final 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>); <span class="comment">//非空</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer); <span class="comment">//仍然为钩子方法</span></span><br><span class="line"></span><br><span class="line">            ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line"></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">            <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">            RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">            NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">            npe.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>subscribe()</code> </p>
<p>​    -&gt; <code>RxJavaPlugins.onSubscribe</code>()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls the associated hook function.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the value type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source the hook's input value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer the observer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned by the hook</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observer&lt;? <span class="keyword">super</span> T&gt; onSubscribe(<span class="meta">@NonNull</span> Observable&lt;T&gt; source, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> Observable, ? <span class="keyword">super</span> Observer, ? extends Observer&gt; f = onObservableSubscribe;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> apply(f, source, observer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> observer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>subscribe()</code> </p>
<p>​    -&gt; <code>RxJavaPlugins.onSubscribe</code>()</p>
<p>​    -&gt; <code>subscribeActual(observer)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br></pre></td></tr></table></figure>
<p>抽象方法，<strong>在<code>ObservableSubscribeOn</code>和<code>ObservableObserceOn</code>都有对应的重写实现</strong>。我们先看<code>ObservableSubscribeOn</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s); </span><br><span class="line">       s.onSubscribe(parent);</span><br><span class="line">       parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里需注意的是 s 这个参数，后面会有很多地方看到这个参数，一定要搞清楚这个参数是谁传递过来的。</p>
<p>比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.subscribe(B); <span class="comment">//那么，参数s就是B</span></span><br></pre></td></tr></table></figure>
<p><code>subscribe()</code> </p>
<p>​    -&gt; <code>RxJavaPlugins.onSubscribe</code>()</p>
<p>​    -&gt; <code>subscribeActual(observer)</code></p>
<p>​        -&gt; <code>scheduler.scheduleDirect()</code></p>
<p><code>scheduler</code>变量就是我们使用<code>subscribeOn()</code>传递的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>schedulerDirect()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scheduleDirect(run, <span class="number">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Worker w = createWorker();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">        DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w);</span><br><span class="line"></span><br><span class="line">        w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法是<code>Scheduler</code>，而当使用<code>Schedulers.computation()</code>时，返回的是一个<code>ComputationScheduler</code>对象，查看<code>ComputationScheduler</code>有没有重写这两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">       PoolWorker w = pool.get().getEventLoop(); <span class="comment">//事件池</span></span><br><span class="line">       <span class="keyword">return</span> w.scheduleDirect(run, delay, unit);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>w.scheduleDirect(run, delay, unit);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        ScheduledDirectTask task = <span class="keyword">new</span> ScheduledDirectTask(RxJavaPlugins.onSchedule(run));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; f;</span><br><span class="line">            <span class="keyword">if</span> (delayTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                f = executor.submit(task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = executor.schedule(task, delayTime, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            task.setFuture(f);</span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">            RxJavaPlugins.onError(ex);</span><br><span class="line">            <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池使用代码。其实就是向我们创建的<code>scheduler</code>里面提交了一个<code>runnable</code>。最终这个<code>Runnable</code>肯定会执行。也就是上文<code>parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</code>传入来的<code>SubscribeTask</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>parent</code>可以直接看到是<code>SubscribeOnObserver</code>对象</li>
<li><code>source</code>是使用外部类的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(source); </span><br><span class="line">    <span class="keyword">this</span>.scheduler = scheduler; </span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123; </span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>); </span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是我们之前分析过的创建<code>ObservableSubscribeOn</code>的代码，这里的<code>this</code>指的是<code>observeOn</code>创建的<code>ObservableObserveOn</code>对象，也就是说，<code>run()</code>里面的代码就是调用了<code>ObservableObserveOn</code>对象的<code>subscribe</code>方法。之前分析过，<code>subscribe()</code>实际上没有做什么，只是调用了<code>subscribeActual()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">           source.subscribe(observer);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">           source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">       &#125;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>
<p><code>observeOn()</code>传递的<code>scheduler</code>不是<code>TrampolineScheduler</code>类型的，所以只需要查看<code>else</code>的代码。这里是先创建了一个工作线程（假设使用的是<code>AndroidScheduler</code>），然后调用了<code>source</code>的<code>subscribe()</code>。需要注意的是这里最后创建了一个<code>ObserveOnOnserver</code>对象。</p>
<p>先看看<code>createWork</code>，在<code>HandlerScheduler</code>。（在<code>AndroidScheduler</code>的<code>DEFAULT</code>中你可以追溯到这里）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HandlerWorker(handler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>handler</code>是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Android-specific Schedulers. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper())); <span class="comment">//可运行在主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/** A &#123;<span class="doctag">@link</span> Scheduler&#125; which executes actions on the Android main thread. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">mainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上知，返回了一个<code>HandlerWorker</code>对象。再接着看看<code>source.subscribe()</code>，首先这里的<code>source</code>指的是<code>create()</code>方法创建的<code>ObservableCreate</code>对象，调用<code>subscribe()</code>传递的是<code>ObserveOnObserver</code>。看看<code>ObservableCreate</code>的<code>subscribeActual()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">       CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">       observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           source.subscribe(parent);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           Exceptions.throwIfFatal(ex);</span><br><span class="line">           parent.onError(ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里的参数<code>observer</code>是<code>ObserveOnObserver</code>，<code>source</code>是我们代码中创建的<code>oos</code>对象。</p>
<p>首先创建了一个<code>CreateEmitter</code>对象。接着看<code>ObserveOnObserver</code>的<code>onSubscribe</code>方法做了啥：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">              <span class="keyword">this</span>.s = s;</span><br><span class="line">              <span class="keyword">if</span> (s <span class="keyword">instanceof</span> QueueDisposable) &#123;</span><br><span class="line">                  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                  QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">int</span> m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (m == QueueDisposable.SYNC) &#123;</span><br><span class="line">                      sourceMode = m;</span><br><span class="line">                      queue = qd;</span><br><span class="line">                      done = <span class="keyword">true</span>;</span><br><span class="line">                      actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">                      schedule();</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (m == QueueDisposable.ASYNC) &#123;</span><br><span class="line">                      sourceMode = m;</span><br><span class="line">                      queue = qd;</span><br><span class="line">                      actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line"></span><br><span class="line">              actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>分析主要代码，就是<code>actual.onSubscribe(this)</code>。<code>actual</code>是构造函数中赋值的，所以我们回到创建<code>ObserveOnObserver</code>的地方，<code>actual</code>指的是<code>SubscribeOnObserver</code>对象。所以它调用了<code>SubscribeOnObserver</code>的<code>onSubscribe()</code>。接下来分析一下它的<code>onSubscribe()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SubscribeOnObserver(SingleObserver&lt;? <span class="keyword">super</span> T&gt; actual, SingleSource&lt;? extends T&gt; source) &#123;</span><br><span class="line">            <span class="keyword">this</span>.actual = actual;</span><br><span class="line">            <span class="keyword">this</span>.source = source;</span><br><span class="line">            <span class="keyword">this</span>.task = <span class="keyword">new</span> SequentialDisposable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            DisposableHelper.setOnce(<span class="keyword">this</span>, d);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setOnce</span><span class="params">(AtomicReference&lt;Disposable&gt; field, Disposable d)</span> </span>&#123; </span><br><span class="line">    ObjectHelper.requireNonNull(d, <span class="string">"d is null"</span>); </span><br><span class="line">    <span class="keyword">if</span> (!field.compareAndSet(<span class="keyword">null</span>, d)) &#123; </span><br><span class="line">        d.dispose(); </span><br><span class="line">        <span class="keyword">if</span> (field.get() != DISPOSED) &#123; </span><br><span class="line">            reportDisposableSet(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>乐观锁</p>
</blockquote>
<p>回到主流程上<code>ObservableCreate</code>的<code>subscribeActual()</code>上，<code>source.subscribe(parent);</code>这是最重要的一句代码。<code>source</code>是在构造函数赋值的，看看构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123; </span><br><span class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>); </span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是这里的<code>source</code>就是我们代码中创建的<code>oos</code>对象。<code>parent</code>是新创建的<code>CreateEmitter</code>对象。看看我们<code>oos</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ObservableOnSubscribe&lt;Integer&gt; oos = <span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = <span class="number">100</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123; </span><br><span class="line">            e.onNext(max); </span><br><span class="line">        &#125; </span><br><span class="line">        e.onComplete(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里就是事件开始的起点，所有事件都由<code>ObservableEmitter</code>开始发送，它是一个接口，在我们的例子中，它的实现类是<code>CreateEmitter</code>，我们分析这个类的<code>onNext()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">        onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>)); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123; </span><br><span class="line">        observer.onNext(t); <span class="comment">//这个observer就是ObserveOnObserver对象</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (done) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123; </span><br><span class="line">        queue.offer(t); </span><br><span class="line">    &#125; </span><br><span class="line">    schedule(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>schedule()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123; </span><br><span class="line">        worker.schedule(<span class="keyword">this</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向<code>worker</code>提交了一个<code>Runnable</code>，这里传递的是<code>this</code>。说明它自己肯定实现了这个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (outputFused) &#123; </span><br><span class="line">        drainFused(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        drainNormal(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> missed = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue; </span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123; </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="keyword">boolean</span> d = done; </span><br><span class="line">            T v; </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                v = q.poll(); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123; </span><br><span class="line">                Exceptions.throwIfFatal(ex); </span><br><span class="line">                s.dispose(); </span><br><span class="line">                q.clear(); </span><br><span class="line">                a.onError(ex); </span><br><span class="line">                worker.dispose(); </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>; </span><br><span class="line">            <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123; </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (empty) &#123; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">            a.onNext(v); </span><br><span class="line">        &#125; </span><br><span class="line">        missed = addAndGet(-missed); </span><br><span class="line">        <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>a.onNext(v)</code>，<code>a</code>是<code>actual</code>变量，<code>actual</code>又是<code>SubscribeOnObserver</code>对象，查看它的<code>onNext()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123; </span><br><span class="line">    actual.onNext(t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，这里的<code>actual</code>就是我们创建的<code>o</code>了，所以最终调用到了我们的代码里面。</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p><code>subscribeOn()</code>，看<code>ObservableSubscribeOn</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);</span><br><span class="line"></span><br><span class="line">       s.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">       parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从这里开始就进行了线程的切换，根据上面的分析指导这里是将<code>SubscribeTask</code>作为一个<code>Runnable</code>对象提交进了我们指定的<code>scheduler</code>（<code>subscribeOn</code>传递的）中，所以后面的流程都是在<code>scheduler</code>所在的线程在运行的。</p>
<p>再看<code>observeOn</code>，看<code>ObservableObserveOn</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123; </span><br><span class="line">        source.subscribe(observer); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        Scheduler.Worker w = scheduler.createWorker(); </span><br><span class="line">        source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); <span class="comment">//发生线程切换</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的线程切换是发生在<code>ObserveOnObserver</code>这个对象里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getAndIncrement() == <span class="number">0</span>)&#123;</span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>schedule</code>，<code>worker.schedule(this)</code>这行代码就发生了线程切换，是将<code>this=</code>作为<code>Runnable</code>对象提交到了我们指定的（<code>observerOn</code>传递的）<code>scheduler</code>中。具体分析，由于之前的流程是在别的线程中，所以想要进行线程切换，最先想到的肯定是<code>Handler</code>。由于我们传递的是<code>AndroidSchedulers.mainThread()</code>，所以我们就分析这个吧。</p>
<p><code>AndroidSchedulers.mainThread()</code>的实现是<code>HandlerScheduler</code>。看看它的<code>schedule()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (run == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"run == null"</span>); </span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit == null"</span>); </span><br><span class="line">    <span class="keyword">if</span> (disposed) &#123; </span><br><span class="line">        <span class="keyword">return</span> Disposables.disposed(); </span><br><span class="line">    &#125; </span><br><span class="line">    run = RxJavaPlugins.onSchedule(run); </span><br><span class="line">    ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run); </span><br><span class="line">    Message message = Message.obtain(handler, scheduled); </span><br><span class="line">    message.obj = <span class="keyword">this</span>; <span class="comment">// Used as token for batch disposal of this worker's runnables. </span></span><br><span class="line">    handler.sendMessageDelayed(message, Math.max(<span class="number">0L</span>, unit.toMillis(delay))); <span class="comment">// 完成线程的切换</span></span><br><span class="line">    <span class="comment">// Re-check disposed state for removing in case we were racing a call to dispose(). </span></span><br><span class="line">    <span class="keyword">if</span> (disposed) &#123; </span><br><span class="line">        handler.removeCallbacks(scheduled); </span><br><span class="line">        <span class="keyword">return</span> Disposables.disposed(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> scheduled; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而此时的<code>Handler</code>是由<code>new HandlerScheduler(new Handler(Looper.getMainLooper()))</code>传入主线程的<code>Looper</code>，故此时它能切换回主线程中。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://www.10tiao.com/img.do?url=https%3A//mmbiz.qpic.cn/mmbiz_png/v1LbPPWiaSt7pQP1OY2Z5Yibfc3R812PxPpp6gUiaSaYnkFUtz5NZA5xub84R57u0ialiczibY1Kwetia2HfowO5bp0ag/640%3Fwx_fmt%3Dpng" alt="流程图"></p>
<p><strong>每次<code>ObserveOn</code>和<code>subscribeOn</code>的时候，内部都会创建一个新的<code>observable</code>和<code>observer</code></strong>。</p>
<p>最后我们<code>subscribe</code>的时候，是调用最后创建的<code>observable</code>的方法。而每个<code>observable</code>内部又调用了<code>source</code>的<code>subscribe</code>方法，这样也就形成了<strong>一层一层的往前传递的调用链</strong>。当调用到最前面的一个<code>observable</code>的时候，就是我们自己创建的<code>observable</code>，在这里我们需要手动触发该<code>observable</code>对应的<code>observer</code>对象的<code>onNext()</code>。而<code>observer</code>的<code>onNext()</code>内部又调用了<code>actual</code>的<code>onNext()</code>，这样就形成了<strong>一层一层往后传递的调用链</strong>。</p>

  </div>
</article>

	<div class="blog-post-comments">
        
        
        <div class="vcomment"></div>
        
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RxJava-笔记"><span class="toc-number">1.</span> <span class="toc-text">RxJava 笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RxJava-的观察者模式"><span class="toc-number">1.1.</span> <span class="toc-text">RxJava 的观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本实现"><span class="toc-number">1.2.</span> <span class="toc-text">基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Observer"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建 Observer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Observable"><span class="toc-number">1.2.2.</span> <span class="toc-text">创建 Observable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subscribe（订阅）"><span class="toc-number">1.2.3.</span> <span class="toc-text">Subscribe（订阅）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程控制——-Scheduler"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程控制—— Scheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scheduler-的-API"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Scheduler 的 API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变换"><span class="toc-number">1.2.5.</span> <span class="toc-text">变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变换的原理：lift"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">变换的原理：lift()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compose-：对-Observable-整体的变换"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">compose()：对 Observable 整体的变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程控制-PLUS"><span class="toc-number">1.2.6.</span> <span class="toc-text">线程控制 PLUS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduler-的原理"><span class="toc-number">1.2.7.</span> <span class="toc-text">Scheduler 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doOnSubscribe"><span class="toc-number">1.2.8.</span> <span class="toc-text">doOnSubscribe()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Observable-create-oos"><span class="toc-number">2.1.</span> <span class="toc-text">Observable.create(oos)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#observeOn-AndroidSchedulers-mainThread"><span class="toc-number">2.2.</span> <span class="toc-text">observeOn(AndroidSchedulers.mainThread())</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subscribeOn-Schedulers-computation"><span class="toc-number">2.3.</span> <span class="toc-text">subscribeOn(Schedulers.computation())</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subscribe-o"><span class="toc-number">2.4.</span> <span class="toc-text">subscribe(o)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程切换"><span class="toc-number">2.5.</span> <span class="toc-text">线程切换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/04/02/关于-RxJava/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/04/02/关于-RxJava/&text=关于 RxJava"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/04/02/关于-RxJava/&is_video=false&description=关于 RxJava"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=关于 RxJava&body=Check out this article: http://yoursite.com/2019/04/02/关于-RxJava/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/04/02/关于-RxJava/&title=关于 RxJava"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/04/02/关于-RxJava/&name=关于 RxJava&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 黄耿
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

<!-- Valine Comments -->

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<script type="text/javascript">
    var notify = 'false' == true ? true : false;
    var verify = 'false' == true ? true : false;
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
      return GUEST_INFO.indexOf(item) > -1
    });
    guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "QkzLlK1k0KOnWTQtGcA7pnfP-gzGzoHsz",
        appKey: "3x2y811wfs2AtVQEz7kKeMhL",
        avatar:"mm",
        placeholder: "say somethings ?",
        guest_info:guest_info,
        pageSize:"10"
    })
</script>
 
</body>
</html>
