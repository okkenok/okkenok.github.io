<!DOCTYPE html>
<html lang=en>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Android 之 View 绘制流程记忆点：Android 界面是怎么显示的？ -&amp;gt; setContentView()涉及到 LayoutInflater -&amp;gt; View 的绘制流程 setContentView 与 LayoutInflatergetWindow().setContentView()    Activity 中有一个成员为 Window， 其实例化对象为 Phone">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 之 View 绘制流程">
<meta property="og:url" content="http://yoursite.com/2019/03/24/Android-之-View-绘制流程/index.html">
<meta property="og:site_name" content="Okkenok">
<meta property="og:description" content="Android 之 View 绘制流程记忆点：Android 界面是怎么显示的？ -&amp;gt; setContentView()涉及到 LayoutInflater -&amp;gt; View 的绘制流程 setContentView 与 LayoutInflatergetWindow().setContentView()    Activity 中有一个成员为 Window， 其实例化对象为 Phone">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://img-blog.csdn.net/20150525162737834">
<meta property="og:image" content="https://img-blog.csdn.net/20150528211332204">
<meta property="og:image" content="https://img-blog.csdn.net/20150529090922419">
<meta property="og:image" content="https://img-blog.csdn.net/20150529163050000">
<meta property="og:image" content="https://img-blog.csdn.net/20150529163153998">
<meta property="og:image" content="https://img-blog.csdn.net/20150530154328068">
<meta property="og:updated_time" content="2019-03-24T09:57:03.295Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 之 View 绘制流程">
<meta name="twitter:description" content="Android 之 View 绘制流程记忆点：Android 界面是怎么显示的？ -&amp;gt; setContentView()涉及到 LayoutInflater -&amp;gt; View 的绘制流程 setContentView 与 LayoutInflatergetWindow().setContentView()    Activity 中有一个成员为 Window， 其实例化对象为 Phone">
<meta name="twitter:image" content="https://img-blog.csdn.net/20150525162737834">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Android 之 View 绘制流程</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/03/22/Android-之事件分发机制/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&text=Android 之 View 绘制流程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&is_video=false&description=Android 之 View 绘制流程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Android 之 View 绘制流程&body=Check out this article: http://yoursite.com/2019/03/24/Android-之-View-绘制流程/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&name=Android 之 View 绘制流程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-之-View-绘制流程"><span class="toc-number">1.</span> <span class="toc-text">Android 之 View 绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#记忆点："><span class="toc-number">1.0.1.</span> <span class="toc-text">记忆点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setContentView-与-LayoutInflater"><span class="toc-number">1.1.</span> <span class="toc-text">setContentView 与 LayoutInflater</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#窗口-PhoneWindow-的setContentView"><span class="toc-number">1.1.1.</span> <span class="toc-text">窗口 PhoneWindow 的setContentView()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LayoutInflater-机制原理"><span class="toc-number">1.1.2.</span> <span class="toc-text">LayoutInflater 机制原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-绘制流程与源码分析："><span class="toc-number">1.2.</span> <span class="toc-text">View 绘制流程与源码分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#View-绘制第一步measure"><span class="toc-number">1.2.1.</span> <span class="toc-text">View 绘制第一步measure</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#measure-原理总结"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">measure() 原理总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-绘制第二步layout"><span class="toc-number">1.2.2.</span> <span class="toc-text">View 绘制第二步layout</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#layout-原理总结"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">layout()原理总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-绘制第三步draw"><span class="toc-number">1.2.3.</span> <span class="toc-text">View 绘制第三步draw</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#第一步，对-View-的背景进行绘制"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">第一步，对 View 的背景进行绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第三步，对-View-的内容进行绘制（第二、第五步可以跳过）"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">第三步，对 View 的内容进行绘制（第二、第五步可以跳过）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第四步，对-View-的所有子-View-进行绘制"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">第四步，对 View 的所有子 View 进行绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第六步，对-View-的滚动条进行绘制"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">第六步，对 View 的滚动条进行绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#draw-原理总结："><span class="toc-number">1.2.3.5.</span> <span class="toc-text">draw()原理总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图状态和视图重绘"><span class="toc-number">1.3.</span> <span class="toc-text">视图状态和视图重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#视图状态"><span class="toc-number">1.3.1.</span> <span class="toc-text">视图状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#视图重绘"><span class="toc-number">1.3.2.</span> <span class="toc-text">视图重绘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postInvalidate"><span class="toc-number">1.3.3.</span> <span class="toc-text">postInvalidate()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他"><span class="toc-number">1.3.4.</span> <span class="toc-text">其他</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#参考引用"><span class="toc-number">2.</span> <span class="toc-text">参考引用</span></a></li>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Android 之 View 绘制流程
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Okkenok</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-03-24T09:56:17.000Z" itemprop="datePublished">2019-03-24</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Android/">Android</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="Android-之-View-绘制流程"><a href="#Android-之-View-绘制流程" class="headerlink" title="Android 之 View 绘制流程"></a>Android 之 View 绘制流程</h2><h4 id="记忆点："><a href="#记忆点：" class="headerlink" title="记忆点："></a>记忆点：</h4><p>Android 界面是怎么显示的？ -&gt; <code>setContentView()</code>涉及到 LayoutInflater -&gt; View 的绘制流程</p>
<h3 id="setContentView-与-LayoutInflater"><a href="#setContentView-与-LayoutInflater" class="headerlink" title="setContentView 与 LayoutInflater"></a>setContentView 与 LayoutInflater</h3><p><code>getWindow().setContentView()</code></p>
<p><img src="https://img-blog.csdn.net/20150525162737834" alt="Window 类的一些关系">  </p>
<p>Activity 中有一个成员为 Window， 其实例化对象为 PhoneWindow， PhoneWindow 为抽象类 Window 的实现类：</p>
<ol>
<li>Window 是一个抽象类，提供了绘制窗口的一组通用 API</li>
<li>PhoneWindow 是 Window 的具体继承实现类，而且该类内部包含了一个 DecorView 对象，该 DecorView 对象是所有应用窗口（Activity 界面）的根 View</li>
<li>DecorView 是 PhoneWindow 的内部类，是 FrameLayout 的子类，是所有应用窗口的根 View</li>
</ol>
<h4 id="窗口-PhoneWindow-的setContentView"><a href="#窗口-PhoneWindow-的setContentView" class="headerlink" title="窗口 PhoneWindow 的setContentView()"></a>窗口 PhoneWindow 的<code>setContentView()</code></h4><p>Activity 中三个重载的<code>setContentView()</code>:<code>setContentView(int layoutResID)</code>、<code>setContentView(View view)</code>、<code>setContentView(View view, ViewGroup.LayoutParams params)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> voids <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nContentParent == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 是否是第一次调用</span></span><br><span class="line">    installDecor();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">    <span class="comment">// 默认为 false</span></span><br><span class="line">    mContentParent.removeAllViews();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(hasFeature(FEATURE_CONTENT_TRANSITIONS))&#123;</span><br><span class="line">    <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext());</span><br><span class="line">    transitionTo(newScene);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// mLayoutInflater 是在 PhoneWindow 的构造函数中得到实力对象的 LayoutInflater.from(context);</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">  <span class="keyword">if</span>(cb != <span class="keyword">null</span> &amp;&amp; !isDestroy())&#123;</span><br><span class="line">    cb.onContentChanged();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mContentParent == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 配置样式、Activity 主题等</span></span><br><span class="line">    installDecor();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">    mContentParent.removeAllViews();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(hasFeature(FEATURE_CONTENT_TRANSITIONS))&#123;</span><br><span class="line">    view.setLayoutParams(params);</span><br><span class="line">    <span class="keyword">final</span> Scene newScene = <span class="keyword">new</span> Scene(mContentParent, view);</span><br><span class="line">    transitionTo(newScene);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    mContentParent.addView(view, params);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">  <span class="keyword">if</span>(cb != <span class="keyword">null</span> &amp;&amp; !isDestroy())&#123;</span><br><span class="line">    cb.onContentChanged();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setContentView(View view)</code>内部也是调用<code>setContentView(View, ViewGroup.LayoutParams params)</code>，只是 LayoutParams 设置为了 MATCH_PARENT 而已。在程序中可多次调用<code>setContentView()</code>,因为会<code>removeAllViews()</code>;流程可概括为：</p>
<ol>
<li>创建一个 DecorView 的对象 mDecor，该对象作为整个应用窗口的根视图。</li>
<li>根据 Feature 等 style theme 创建不同的窗口修饰布局文件，并通过<code>findViewById()</code>获取 Activity 布局文件存放的地方（窗口修饰布局文件 id 为 content 的 FrameLayout 内）。</li>
</ol>
<p>当启动 Activity 掉运完 ActivityThread 的<code>main()</code>方法之后，接着调用 ActivityThread 类的<code>performLaunchActivity()</code>来创建需要启动的 Activity 组件，在创建 Activity 组件的过程中，还会为该 Activity 组件创建窗口对象和视图对象，接着 Activity 组件创建完成后，通过调用 ActivityThread 的<code>hadnleResumeActivity()</code>将它激活，在方法中<code>r.activity.makeVisible()</code>显示我们上面<code>setContentView()</code>创建的 mDecor 视图族。</p>
<h4 id="LayoutInflater-机制原理"><a href="#LayoutInflater-机制原理" class="headerlink" title="LayoutInflater 机制原理"></a>LayoutInflater 机制原理</h4><p>获取 LayoutInflater 实例的两种写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater lif = LayoutInflater.from(context);<span class="comment">//其实就是对下面方式的封装</span></span><br><span class="line">LayoutInflater lif = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></p>
<p><code>layoutInflater.inflate()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span> <span class="params">(<span class="keyword">int</span> resource, ViewGroup root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>layoutInflater.inflate(resource, root)</code>-&gt;<code>layoutInflater.inflate(resource, root, true/false)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//Android 默认实现为 Pull 解析的实现类 XmlPullParser</span></span><br><span class="line">  <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    parser.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>layoutInflater.inflate(resource, root)</code>-&gt;<code>layoutInflater.inflate(resource, root, attachToRoot)</code>-&gt;<code>inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(mContructorArgs)&#123;</span><br><span class="line">    Trace.tarceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"inflate"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">    Context lastContext = (Context)mContructorArgs[<span class="number">0</span>];</span><br><span class="line">    mContructorArgs[<span class="number">0</span>] = mContext;</span><br><span class="line">    View result = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> type;</span><br><span class="line">      <span class="comment">// 找根节点</span></span><br><span class="line">      <span class="keyword">while</span>((type = parser.next) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT)&#123;</span><br><span class="line">        <span class="comment">// empty</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果</span></span><br><span class="line">      <span class="keyword">if</span>(type != XmlPullParser.START_TAG)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription() + <span class="string">": No start tag found!"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> String name = parser.getname();</span><br><span class="line">      <span class="keyword">if</span>(TAG_MERGE.equals(name))&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || !attachToRoot)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"merge can be used only with a valid ViewGroup root and attach = true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rInflate(parser, root, attrs);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 方法内部又会去调用 createView()</span></span><br><span class="line">        <span class="comment">// 然后使用反射的方式创建出 View 的实例并返回</span></span><br><span class="line">        View temp = createViewFromTag(name, attrs);</span><br><span class="line">        ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          params = root.generateLayoutParams(attrs);</span><br><span class="line">          <span class="keyword">if</span>(!attachToRoot)&#123;</span><br><span class="line">            temp.setLayoutParams(params)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rInflate(parser, temp, attrs);</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; attachToRoot)&#123;</span><br><span class="line">          root.addView(temp, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || !attachToRoot)&#123;</span><br><span class="line">          result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(XmlPullParserException e)&#123;</span><br><span class="line">      InflateException ex = <span class="keyword">new</span> InflateException(e.getMessage());</span><br><span class="line">      ex.initCause(e);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">      InflateException ex = <span class="keyword">new</span> InflateException(parser.getPositionDescription() + <span class="string">": "</span> + e.getMessage());</span><br><span class="line">      ex.initCause(e);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LayoutInflater 使用的是 Android 提供的 pull 解析方式来解析 xml 布局文件的。以上只是创建了一个根布局实例而已，接下来会调用<code>rInflate()</code>方法来循环遍历这个根布局下的子元素。其中获取 View 的方法是<code>createViewFromTag()</code>,通过反射的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rInflate</span><span class="params">(XmlPullParser parser, View parent, <span class="keyword">final</span> AttributeSet attrs)</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> depth = parser.getDepth();</span><br><span class="line">  <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">while</span>(()(type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT)&#123;</span><br><span class="line">    <span class="keyword">if</span>(type != XmlPullParser.START_TAG)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">    <span class="keyword">if</span>(TAG_REQUEST_FOCUS.equals(name))&#123;</span><br><span class="line">      parseRequestFocus(parser, parent);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TAG_INCLUDE.equals(name))&#123;</span><br><span class="line">      <span class="keyword">if</span>(parser.getDepth() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;include /&gt; cannot be the root element"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parseInclude(parser, parent, attrs);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TAG_MERGE.equals(name))&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; must be the root element"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">final</span> View view = createViewFromTag(name, attrs);</span><br><span class="line">      <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">      <span class="keyword">final</span> ViewGruop.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">      rInflate(parser, view, attrs);</span><br><span class="line">      viewGroup.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parent.onFinishInflate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上可以看出，布局嵌套过深不仅效率低还可能引起调运栈溢出。同时在解析 tag  时也有一些特殊处理（include\merge）。布局优化可以通过 hierarchyviewer 来查看，通过 Lint 也可以自动检查出来一些。<a href="https://okkenok.github.io/2019/03/20/Android%E4%B9%8B%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96-1/" target="_blank" rel="noopener">关于布局优化</a></p>
<p><strong><code>setContentView()</code>整个过程主要是如何把 Activity 的布局文件或者 Java 的 View 添加至窗口：</strong>  </p>
<ol>
<li>创建一个 DecorView 的对象 mDecor，该对象作为整个应用窗口的根视图；</li>
<li>依据 Feature 等 style theme 创建不同的窗口修饰布局文件，并通过 findViewById 获取 Activity 布局文件该存放的地方（窗口修饰布局文件中 id 为 content 的 FrameLayout）；</li>
<li>将 Activity 的布局文件添加到 id 为 content 的 FrameLayout 内；</li>
<li>当<code>setContentView()</code>设置显示为 OK 以后会回调 Activity 的<code>onContentChanged()</code>。Activity 的各种 View 的<code>findViewById()</code>方法等都可以放到该方法中，系统会帮忙回调。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20150528211332204" alt="View 渲染关系"></p>
<h3 id="View-绘制流程与源码分析："><a href="#View-绘制流程与源码分析：" class="headerlink" title="View 绘制流程与源码分析："></a>View 绘制流程与源码分析：</h3><p>每一个 View 绘制都经历三个最主要的过程：<strong>measure -&gt; layout -&gt; draw</strong><br>整个 View 树的绘图流程是在 ViewRootImpl 类的<code>performTraversals()</code>开始的。该函数功能主要是根据之前设置的状态，判断是否重新计算视图的大小<code>measure</code>，是否重新安放视图位置<code>layout</code>，以及是否重绘<code>draw</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// lp.width 和 lp.height 在创建 ViewGroup 实例的时候就被赋值了，都等于 MATCH_PARENT</span></span><br><span class="line">  <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">  <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">  ...</span><br><span class="line">  mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">  ...</span><br><span class="line">  mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">  ...</span><br><span class="line">  mView.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Figures out the measure spec for the root view in a window based on it's</span></span><br><span class="line"><span class="comment">     * layout params.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> windowSize</span></span><br><span class="line"><span class="comment">     *            The available width or height of the window</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rootDimension</span></span><br><span class="line"><span class="comment">     *            The layout params for one dimension (width or height) of the</span></span><br><span class="line"><span class="comment">     *            window.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The measure spec to use to measure the root view.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> measureSpec;</span><br><span class="line">  <span class="keyword">switch</span>(rootDimension)&#123;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">      <span class="comment">// RootView 全屏的原因：windowSize, EXACTLY.</span></span><br><span class="line">      measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mView 就是 View 对象。以下就是整个流程的大致流程图：</p>
<p><img src="https://img-blog.csdn.net/20150529090922419" alt="大致流程图"></p>
<h4 id="View-绘制第一步measure"><a href="#View-绘制第一步measure" class="headerlink" title="View 绘制第一步measure"></a>View 绘制第一步<code>measure</code></h4><p><img src="https://img-blog.csdn.net/20150529163050000" alt="measure 流程"></p>
<p>View 的<code>measure()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为整个 View 树设置实际的阿晓，然后设置实际的高和宽，<strong>每个 View 控件的实际宽高都是由父视图和自身决定的</strong>。<code>measure()</code>不可被重写，实际的测量是在<code>onMeasure()</code>中进行。<br>关于 widthMeasureSpec/heightMeasureSpec，这两个参数是从父 View 传递过来，代表了父 View 的规格。</p>
<blockquote>
<p>MeasureSpec: 32位，也就是 specMode + specSize，高2位表示 MODE，低30位表示 size (也就是父 View 的大小)<br><strong>MeasureSpec.EXACTLY</strong>：表示父视图希望子视图的大小应该是由 specSize 的值来决定的，系统会默认按照这个规则来设置子视图的大小，开发人员也可按照自己的意愿设置成任意大小。<br><strong>MeasureSpec.AT_MOST</strong>：表示子视图最多只能是 specSize 中指定的大小，开发人员应该尽可能小的去设置这个视图，并且保证不会超过 specSize。系统会默认按照这个规则来设置子视图大小，开发人员也可以按照自己的意愿设置成任意大小。<br><strong>MeasureSpec.UNSPECIFIED</strong>：表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。</p>
</blockquote>
<p><code>measure()</code>-&gt;<code>onMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class="line">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onMeasure()</code>是真正去测量并设置 View 大小的地方，默认会调用<code>getDefaultSize()</code>方法来获取视图的大小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = size;</span><br><span class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">  <span class="keyword">switch</span>(specMode)&#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">      result = size;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">      result = specSize;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里传入的 measureSpec 是一直<code>measure()</code>中传递过来的。系统这时默认行为是如果传递过来的 specMode 是 AT_MOST 或是 EXACTLY 就返回 specSize。之后通过<code>setMeasuredDimension()</code>来设定测量出的大小，这样一次<code>measure</code>过程就结束了。而一个布局中一般都会包含多个子视图，每个视图都需要一次<code>measure</code>的过程。在 ViewGroup 中定义了<code>measureChild()</code>、<code>measureChildren()</code>、<code>measureChildWithMargins()</code>方法来对子视图进行测量。<code>measureChildren()</code>内部实质只是循环调用了<code>measureChild()</code>,<code>measureChild()</code>和<code>measureChildWithMargins()</code>的区别只是是否把 margin 和 padding 也作为子视图的大小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">  <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123;</span><br><span class="line">    <span class="keyword">final</span> View child = children[i];</span><br><span class="line">    <span class="keyword">if</span>((child.mViewFlags &amp; VISIBILITY) != GONE)&#123;</span><br><span class="line">      measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> parentHeightMeasureSpec)</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> LayoutParams lp = child.getLaoutParams();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line">  child.measure(chlidWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getChildMeasureSpec()</code>去计算子视图的 MeasureSpec，计算的依据是布局文件中定义的 MATCH_PARENT、WRAP_CONTENT 等值。然后再调用子视图的<code>measure()</code>，并把计算出的 MeasureSpec 传递进去，之后的流程与前面介绍的相同。</p>
<h5 id="measure-原理总结"><a href="#measure-原理总结" class="headerlink" title="measure() 原理总结"></a><code>measure()</code> 原理总结</h5><p>从顶层父 View 向子 View 递归调用<code>view.measure()</code>（<code>measure()</code>中又回调<code>onMeasure()</code>）</p>
<ul>
<li>MeasureSpec：EXACTLY、AT_MOST、UNSPECIFIED</li>
<li>View 的<code>measure()</code>是 final 的，不允许重写，View 子类只能重写<code>onMeasure()</code>来完成自己的测量逻辑</li>
<li>顶层 DecorView 测量时的 MeasureSpec 是由 ViewRootImpl 中的<code>getRootMeasureSpec()</code>方法确定的（LayoutParams 宽高参数均为 MATCH_PARENT，specMode 是 EXACTLY，specSize 为物理屏幕的大小）。</li>
<li>使用 View 的<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法来获取 View 测量的宽高，必须保证这两个方法在<code>onMeasure()</code>流程之后被调用才能返回有效值。</li>
</ul>
<h4 id="View-绘制第二步layout"><a href="#View-绘制第二步layout" class="headerlink" title="View 绘制第二步layout"></a>View 绘制第二步<code>layout</code></h4><p>当 ViewRootImpl 的<code>performTraversals</code>中的<code>measure()</code>执行完成以后会接着执行<code>mView.layout()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mView.layot(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>layout()</code>接收的四个参数，分别代表着左、上、右、下的坐标，这个坐标是相对于当前视图的父视图而言的</p>
<p>整个 View 树的<code>layout()</code>递归流程：</p>
<p><img src="https://img-blog.csdn.net/20150529163153998" alt="layout 递归流程"></p>
<p>layout 也是递归结构，ViewGroup 的<code>layout()</code>实际还是调用的 View 父类的<code>layout()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//实际都是调用`setFrame()`把参数分别赋值给 mLeft、mTop、mRight 和 mBottom 这几个变量</span></span><br><span class="line">    <span class="comment">//判断 View 位置是否发生过变化，以确定有没有必要对当前的 View 进行重新`layout()`</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ? setOptionalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    <span class="keyword">if</span>(changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED)&#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ViewGroup 中的<code>onLayout()</code>竟然是一个抽象方法，这就意味着所有 ViewGroup 的子类都必须重写这个方法，在内部按照自己的规则对子视图进行布局。以 LinearLayout 为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> t, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mOrientation == VERTICAL)&#123;</span><br><span class="line">            layoutVertical(l, t, r, b);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            layoutHorizontal(l, t, r, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> childTop;</span><br><span class="line">    <span class="keyword">int</span> childLeft;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = right - left; <span class="comment">//计算父窗口推荐的子 View 的宽度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childRight = width - mPaddingRight; <span class="comment">//计算父窗口推荐的子 View 右侧位置</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> childSpace = width -  paddingLeft - mPaddingRight; <span class="comment">//child 可使用空间的大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount(); <span class="comment">// 获取子 View 个数</span></span><br><span class="line">    <span class="comment">//获取 Gravity 属性设置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">    <span class="keyword">switch</span>(majorGravity)&#123;</span><br><span class="line">        <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">            childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">            childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            childTop = mPaddingTop;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVidtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span>(child == <span class="keyword">null</span>)&#123;</span><br><span class="line">            childTop += measureNullChild(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(child.getVisibility() != GONE)&#123;</span><br><span class="line">            <span class="comment">// LinearLayout 中子视图显示的宽和高由`measure()`过程来决定的。因此`measure()`过程的意义就是为`layout()`过程提过视图显示范围的参考值</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)child.getLayoutParams();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span>(gravity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                gravity = minorGravity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGraviry(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">switch</span>(absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK)&#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft += paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>) + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(hasDividerBeforeChildAt(i))&#123;</span><br><span class="line">                childTop += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            childTop += lp.topMargin;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//通过垂直排列计算调运 child 的 layout 设置 child 的位置</span></span><br><span class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);</span><br><span class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line">            </span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上可以看到，一般情况下<code>layout()</code>过程会参考<code>measure()</code>过程中计算得到的 mMeasuredWidth 和 mMeasuredHeight 来安排子 View 在父 View 中显示的位置，但这不是必须的，<code>measure()</code>过程得到的结果可能完全没有实际用处。</p>
<h5 id="layout-原理总结"><a href="#layout-原理总结" class="headerlink" title="layout()原理总结"></a><code>layout()</code>原理总结</h5><ul>
<li>View 的 <code>layout()</code>方法可被重写，但是 ViewGroup 的<code>layout()</code>为 final，ViewGroup 的<code>onLayout()</code>为 abstract 的，子类必须重写实现自己的布局逻辑</li>
<li><code>measure()</code>操作后得到的是每个 View 经过测量过的 measuredWidth 和 measuredHeight，<code>layout()</code>操作之后得到的是对每个 View 进行位置分配后的 mLeft、mTop、mRight、mBottom，这些都是相对父 View 来说的</li>
<li>凡是 layout_XXX 的布局属性基本都是针对的是包含子 View 的 ViewGroup 的。为一个没有父容器设置相关的 layout_XXX 属性是没有任何意义的</li>
<li>使用 View 的<code>getWith()</code>和<code>getHeight()</code>方法来获取 View 测量的宽高，必须保证这两个方法在<code>onLayout()</code>流程之后被调用才能返回有效值</li>
</ul>
<h4 id="View-绘制第三步draw"><a href="#View-绘制第三步draw" class="headerlink" title="View 绘制第三步draw"></a>View 绘制第三步<code>draw</code></h4><p><code>draw()</code>过程也是在 ViewRootImpl 的<code>performTraversals()</code>内部调用的，其调用顺序在<code>measure()</code>和<code>layout()</code>之后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    ...</span><br><span class="line">    canvas = mSurface.lockCanvas(dirty); <span class="comment">// ViewRootImpl中的代码会创建一个 Canvas 对象</span></span><br><span class="line">    ...</span><br><span class="line">    mView.draw(canvas); <span class="comment">// 对于 Activity 来说就是 PhoneWindow.DecorView</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View 递归 draw 流程：</p>
<p><img src="https://img-blog.csdn.net/20150530154328068" alt="递归 draw 流程"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Draw taversal performs serveral drawing steps which must be executed in the approptiate order:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 1.Draw the background</span></span><br><span class="line"><span class="comment">    * 2.If necessary, save the canvas's layers to prepare for fading</span></span><br><span class="line"><span class="comment">    * 3.Draw view's content</span></span><br><span class="line"><span class="comment">    * 4.Draw children</span></span><br><span class="line"><span class="comment">    * 5.If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">    * 6.Draw decorations (scroller for instance)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 1</span></span><br><span class="line">    <span class="keyword">if</span>(!dirtyOpaque)&#123;</span><br><span class="line">    	drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 2    </span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(drawTop)&#123;</span><br><span class="line">    	canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 3</span></span><br><span class="line">    <span class="keyword">if</span>(!dirtyOpaque)&#123;</span><br><span class="line">    	onDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 4</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 5</span></span><br><span class="line">    <span class="keyword">if</span>(drawTop)&#123;</span><br><span class="line">    	matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Step 6</span></span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第一步，对-View-的背景进行绘制"><a href="#第一步，对-View-的背景进行绘制" class="headerlink" title="第一步，对 View 的背景进行绘制"></a>第一步，对 View 的背景进行绘制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 xml 中通过 android:background 属性或者代码中`setBackgroundColor()`、`setBackgroundResource()`等方法进行赋值的背景 Drawable</span></span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(mBackgroundSizeChanged)&#123;</span><br><span class="line">    	<span class="comment">// 根据`layout()`过程确定的 View 位置来设置背景的绘制区域</span></span><br><span class="line">        background.setBounds(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">        mBackgroundSizeChanged = <span class="keyword">false</span>;</span><br><span class="line">        rebuildOurline();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    background.draw(canvas); <span class="comment">//调用 Drawable 的`draw()`来完成背景的绘制工作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第三步，对-View-的内容进行绘制（第二、第五步可以跳过）"><a href="#第三步，对-View-的内容进行绘制（第二、第五步可以跳过）" class="headerlink" title="第三步，对 View 的内容进行绘制（第二、第五步可以跳过）"></a>第三步，对 View 的内容进行绘制（第二、第五步可以跳过）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>空方法。这是因为每个 View 的内容部分是各不相同，需要具体子类实现具体逻辑</p>
<h5 id="第四步，对-View-的所有子-View-进行绘制"><a href="#第四步，对-View-的所有子-View-进行绘制" class="headerlink" title="第四步，对 View 的所有子 View 进行绘制"></a>第四步，对 View 的所有子 View 进行绘制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>也是一个空方法。如果 View 包含子 View 需要重写它，看看 ViewGroup 的<code>dispatchDraw()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        	more |= drawChild(canvas, child, drawingTime);    </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Draw any disappearing views that have animations</span></span><br><span class="line">    <span class="keyword">if</span>(mDisappearingChildren != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = disappearingCount; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            ...</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup 确实重写了 View 的<code>dispatchDraw()</code>，该方法内部会遍历每个子 View，然后调用<code>drawChild()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawChild()</code>调用了子 View 的<code>draw()</code>。ViewGroup 类已经为我们重写了<code>dispatchDraw()</code>的功能实现，一般不需要重写该方法，但可以重写父类函数实现具体的功能</p>
<h5 id="第六步，对-View-的滚动条进行绘制"><a href="#第六步，对-View-的滚动条进行绘制" class="headerlink" title="第六步，对 View 的滚动条进行绘制"></a>第六步，对 View 的滚动条进行绘制</h5><p>onDrawScrollBars(canvas);</p>
<h5 id="draw-原理总结："><a href="#draw-原理总结：" class="headerlink" title="draw()原理总结："></a><code>draw()</code>原理总结：</h5><ul>
<li>如果该 View 是一个 ViewGroup，则需递归绘制其包含的所有子 View</li>
<li>View 默认不会绘制任何内容，真正的绘制都需要在子类中实现</li>
<li>View 的绘制是借助<code>onDraw()</code>方法传入 Canvas 类进行的</li>
<li>默认情况下的子 View 的 ViewGroup.drawChld 的绘制顺序和子 View 被添加的顺序一致，但是你可以重写<code>ViewGroup.getChildDrawingOrder()</code>方法提供不同的顺序。</li>
</ul>
<h3 id="视图状态和视图重绘"><a href="#视图状态和视图重绘" class="headerlink" title="视图状态和视图重绘"></a>视图状态和视图重绘</h3><h4 id="视图状态"><a href="#视图状态" class="headerlink" title="视图状态"></a>视图状态</h4><p>常见几个：enabled（是否可用，不可用无法响应<code>onTouch</code>事件）、focused、window_focused、selected、pressed…</p>
<h4 id="视图重绘"><a href="#视图重绘" class="headerlink" title="视图重绘"></a>视图重绘</h4><p>调用<code>setVisibility()</code>、<code>setEnabled()</code>、<code>setSelected()</code>等方法时都会导致视图重绘，而如果想要手动强制让视图进行重绘，可用通过调用<code>invalidate()</code>来实现。其实上述方法内部也是调用此方法实现重绘。各种重载的<code>invalidate()</code>最终调用的都是<code>invalidateInternal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache, <span class="keyword">boolean</span> full Invalidate)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">    <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b)&#123;</span><br><span class="line">        <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">        <span class="comment">// 设置刷新区域</span></span><br><span class="line">        damage.set(l, t, r, b);</span><br><span class="line">        <span class="comment">// 传递调用 Parent ViewGroup 的刷新方法</span></span><br><span class="line">        p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个向上级父 View 回溯的过程，每一层的父 View 都将自己的显示区域与传入的刷新的 Rect 做交集。看看 ViewGroup 的 invalidateChild 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span></span>&#123;</span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        parent = parent.invalidateChildInParent(location, dirty);<span class="comment">//循环层层上级调用，直到 ViewRootImpl 会返回 null</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(parent != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上过程最后传递到 ViewRootImpl 的<code>invalidateChildInParent()</code>方法结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    scheduleTraversals();<span class="comment">// 会通过 Handler 的 Runnable 发送一个异步消息，调用`doTraversal()`，最终调用`performTraversals()`执行重绘。</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="postInvalidate"><a href="#postInvalidate" class="headerlink" title="postInvalidate()"></a>postInvalidate()</h4><p>实际就是子线程通过 ViewRootImpl 类的<code>dispatchInvalidateDelayed()</code>，通过 Handler 发送 MSG_INVALIDATE 消息，ViewRootImpl 中的 Handler 收到消息就又在 UI 线程中调用了 View 的<code>invalidate()</code>方法。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>setContentView()</code>的<code>addView()</code>会通过<code>invalidate(true)</code>触发 ViewRootImpl 类的`performTraversals()  </p>
<p><code>requestLayout()</code>层层上传到 ViewRootImpl 后触发 ViewRootImpl 中的<code>requestLayout()</code>中的<code>scheduleTraversals()</code>。<code>requestLayout()</code>会调用<code>measure()</code>过程和<code>layout()</code>过程，但不会调用<code>draw()</code>，也不会重绘任何子 View包括调用者自身。</p>
<hr>
<h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p><a href="https://blog.csdn.net/guolin_blog/article/details/12921889" target="_blank" rel="noopener">Android LayoutInflater原理分析，带你一步步深入了解View(一)</a>  </p>
<p><a href="https://blog.csdn.net/yanbober/article/details/45970721" target="_blank" rel="noopener">Android应用setContentView与LayoutInflater加载解析机制源码分析</a></p>
<p><a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="noopener">Android应用层View绘制流程与源码分析</a></p>

  </div>
</article>

	<div class="blog-post-comments">
        
        
        <div class="vcomment"></div>
        
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-之-View-绘制流程"><span class="toc-number">1.</span> <span class="toc-text">Android 之 View 绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#记忆点："><span class="toc-number">1.0.1.</span> <span class="toc-text">记忆点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setContentView-与-LayoutInflater"><span class="toc-number">1.1.</span> <span class="toc-text">setContentView 与 LayoutInflater</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#窗口-PhoneWindow-的setContentView"><span class="toc-number">1.1.1.</span> <span class="toc-text">窗口 PhoneWindow 的setContentView()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LayoutInflater-机制原理"><span class="toc-number">1.1.2.</span> <span class="toc-text">LayoutInflater 机制原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-绘制流程与源码分析："><span class="toc-number">1.2.</span> <span class="toc-text">View 绘制流程与源码分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#View-绘制第一步measure"><span class="toc-number">1.2.1.</span> <span class="toc-text">View 绘制第一步measure</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#measure-原理总结"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">measure() 原理总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-绘制第二步layout"><span class="toc-number">1.2.2.</span> <span class="toc-text">View 绘制第二步layout</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#layout-原理总结"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">layout()原理总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-绘制第三步draw"><span class="toc-number">1.2.3.</span> <span class="toc-text">View 绘制第三步draw</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#第一步，对-View-的背景进行绘制"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">第一步，对 View 的背景进行绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第三步，对-View-的内容进行绘制（第二、第五步可以跳过）"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">第三步，对 View 的内容进行绘制（第二、第五步可以跳过）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第四步，对-View-的所有子-View-进行绘制"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">第四步，对 View 的所有子 View 进行绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第六步，对-View-的滚动条进行绘制"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">第六步，对 View 的滚动条进行绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#draw-原理总结："><span class="toc-number">1.2.3.5.</span> <span class="toc-text">draw()原理总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图状态和视图重绘"><span class="toc-number">1.3.</span> <span class="toc-text">视图状态和视图重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#视图状态"><span class="toc-number">1.3.1.</span> <span class="toc-text">视图状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#视图重绘"><span class="toc-number">1.3.2.</span> <span class="toc-text">视图重绘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postInvalidate"><span class="toc-number">1.3.3.</span> <span class="toc-text">postInvalidate()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他"><span class="toc-number">1.3.4.</span> <span class="toc-text">其他</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#参考引用"><span class="toc-number">2.</span> <span class="toc-text">参考引用</span></a></li>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&text=Android 之 View 绘制流程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&is_video=false&description=Android 之 View 绘制流程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Android 之 View 绘制流程&body=Check out this article: http://yoursite.com/2019/03/24/Android-之-View-绘制流程/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&title=Android 之 View 绘制流程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/03/24/Android-之-View-绘制流程/&name=Android 之 View 绘制流程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 黄耿
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

<!-- Valine Comments -->

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<script type="text/javascript">
    var notify = 'false' == true ? true : false;
    var verify = 'false' == true ? true : false;
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
      return GUEST_INFO.indexOf(item) > -1
    });
    guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "QkzLlK1k0KOnWTQtGcA7pnfP-gzGzoHsz",
        appKey: "3x2y811wfs2AtVQEz7kKeMhL",
        avatar:"mm",
        placeholder: "say somethings ?",
        guest_info:guest_info,
        pageSize:"10"
    })
</script>
 
</body>
</html>
